[{"content":"DeformableDETR 1.DETR 1.1 简述 Detr将目标检测任务看作是集合预测问题，在每次将所有的object都做出预测，之后与GroundTruth进行二分图匹配，每一个object预测结果都会对应一个种类与位置(当然其中包含背景种类)；并且使用transformer来构建模型，对所有的objectquery来并行预测。\n相比较以往的目标检测模型，DETR主要有以下几个创新点：\n将目标检测任务看作是集合预测问题，并为此设计了损失函数，得到固定数量的object预测之后与真实值进行二分匹配，从而不需要以往的去重工作（如NMS） 使用transformer来并行预测与建模，不再需要先验知识(如anchor的设计) 总之，detr是首个真正的端到端目标检测模型，也是将transformer运用到目标检测任务中的首次尝试。\n1.2损失函数（Object detection set prediction loss） DETR每次得出固定数量$N$ 的预测结果，当然$N$ 需要大于在图片中出现的物体数量，之后得出这些预测结果与真实值之间的最佳二分匹配，得出最佳匹配的方法表示如下：\n其中，$y$ 代表所预测目标的真实值，当然其中包括物体的种类与位置；$\\hat y={\\hat y_i}{i=1}^{N}$ 表示对每个objectquery得到的预测结果,$\\sigma(i)$ 则表示对于第$i$ 个预测结果所匹配到的groundtruth的索引，$\\ell{match}(y_i,\\hat y_{\\sigma(i)})$ 表示二者之间的匹配成本。我们最终需要的使匹配成本最小的$\\sigma$ 。当然这里可以使用匈牙利算法。\n1.2.1匹配成本 这里的匹配成本同时考虑了物体的种类与位置，即$\\hat y = (c_i,b_i)$ ,其中$c_i$表示物体种类，$b_i \\in [0,1]^4$ 为包含ground box中心坐标与长、宽的向量。对于索引$\\sigma(i)$ 我们将该索引对应的预测结果分类为$c_i$ 的概率表示为$p_{\\sigma(i)}(c_i)$ ,将其预测的box表示为$\\hat b_{\\sigma (i)}$ ，因此可以将匹配成本函数定义为：$L_{match}(y_i, \\hat y_{\\sigma(i)}) =−1_{c_i\\not=\\emptyset}\\hat p_{\\sigma(i)}(c_i) + 1_{c_i\\not=\\emptyset} L_{box}(b_i, \\hat b_{\\sigma_i}(i))$ 。这样的过程与以往的目标检测算法中为anchor或者proposal分配真实值的工作效果相同，当然区别在与我们得到的是一一对应的匹配，不存在重复的问题。\n1.2.2 标记框损失(Bounding box loss) 因为本模型是直接做出对于box的预测的，所以会遇到不同尺度下损失的相对缩放。常用的$l_1$ 损失会跟随预测框的大小产生缩放，即使这两种预测框的错误程度是相同的。而IoU损失的尺度是不变的，因此这里将$l_1$ 损失与IoU损失做线性组合，成为我们需要的boxloss，如下：\n当然，其中$\\lambda_{iou}$ 与$\\lambda_{L_1}$ 都是超参数。\n1.2.3 损失函数 之后就可以定义匹配的损失函数如下：\n1.3 网络结构 (DETR architecture) 先上图\n1.3.1 Backbone 即:使用CNN从原始三通道图像$x_{img}\\in R^{3\\times H_0 \\times W_0}$ 抽取出特征图$f \\in R^{d \\times h \\times w}$ 。在原文中，$C=2048$,$h,w=h_0/32,w_0/32$\n1.3.2 Transformer Encoder 在编码器中，首先使用$1 \\times 1$卷积核，将特征图f 的通道数从C降为d，创建特征图$z_0 \\in R^{d \\times h \\times w}$。因为transformer的编码器需要的是序列化的输入，因此再将$z_0$展平为$d \\times hw$的序列，这个时候每个像素点可以类比为序列中的一个word embedding；之后按照transformer的流程，再加入位置编码，不同的是，每一次进行注意力机制之前都需要加入一次位置编码，不同于transformer的只加入一次。\n之后即可进行多头自注意力机制与前馈网络(FFN)，与transformer一致。\n1.3.3 Transformer Decoder 解码器同样与transformer非常相近，输入为N个objectqurey,长度为d，这些作为query进行多头注意力与自注意力机制。不同点在于，原transformer在做预测的时候依然是串行进行的，即每次根据之前的输入预测下一个元素；而本文中则是对所有的object query并行做出预测，同时产生$N$ 个预测结果，当然这些预测结果都是各不相同的。\n多次提到的object query,实际上就是一种可学习的位置编码，当然也同样在每层中的注意力机制加入。\n得益于attention，我们可以同时看到整张图片，从而做出充分考虑上下文内容的预测；但是超大的感受野也为detr埋下了隐患。\n1.3.4 FFNs 在decoder中，N个object query会产生N个输出，而最终的预测结果是由FFN加工完成的。对于decoder输出的embedding,FFN用一个具有ReLU激活函数和d维隐藏层的3层感知机，来根据输出得到预测框的相对于原图归一化后中心点坐标、长和宽；再通过具有softmax的线性映射将输出映射为预测类别。\n1.3.5 辅助 在训练时，还用到了辅助的损失函数，来帮助模型正确输出每个种类的物体的数量。具体为在每层decoder中都使用FFN与匈牙利损失。所有的FFN都具有相同的参数。\n1.4 DETR的局限性 detr成功得将transformer运用到目标检测领域，代替了此前在目标检测中的anchor标准和筛选处理，成为第一个完全端到端目标检测器，但是它仍然存在一些问题：\n由于transformer的特性(注意力机制能同时看到所有字)导致计算开销大，收敛慢 处理图像的分辨率有限制，在小目标识别方面有提升空间(但只是相对于DETR来说) 基于为了改进以上两点，本文提出了DeformalbeDETR\n2. DCN 接下来需要了解可变形卷积的基本思想。\n2.1普通卷积 普通卷积运算公式如下：\n其中，$p_0$代表卷积核心的坐标，$p_n$ 代表卷积核感受野中需要纳入考量的单元相对于核心的偏移量。\n可入下图所示：\n在普通卷积下，相对于核心的偏移都是固定的，这也限制了卷积的感受野，对于学习到较远距离元素的关系计算开销很大。\n2.2可变形卷积 计算公式：\n可变形卷积中进一步加入了$\\triangle p_n$ ，是通过一层卷积的到的值，学习方法：\n$\\triangle p_n$是通过在特征图上增加一个卷积层来得到的。这个卷积核的尺寸与可变形卷积的尺寸一致。输出的offset fields有着与输入特征图一样的尺寸，通道维度2N与N个2D的offsets相关联\n这里offsetfield的channel数为18（9个点的偏移量，每个量2个参数）\n$\\triangle p_n$代表偏移量的偏移量，如下图所示：\n当然$\\triangle p_n$ 通常是小数，为了计算参与卷积运算的点的值，这里会选择距编译点最近的四个点进行双线性差值，其结果参与卷积运算。\n因此可变形卷积可如下表示：\n3.DeformableDETR 为了解决DETR中的两个问题，该论文有以下两个创新点：\n3.1可变性注意力模块(Deformable Attention Module) 针对注意力机制会处理所有位置的token,参考可变形卷积，不论特征图有多大，对于每个query只对有限的几个key应用注意力机制(在代码中这个采样的数量是4)，减少了运算开销，从而缓解收敛满和图像分辨率限制的问题。\n对于特征图$x \\in R^{C\\times H \\times W}$ ，$z_q$ 表示特征图中的一个token,$p_q$ 表示该token在特征图中的二维坐标(类比卷积)，则可变形注意力机制可以表示为：\n其中，m标准多头注意力的序号；k表示采样得到的key的序号；$\\Delta P_{mqk}$ 表示对于key采样的偏移，由query $z_q$ 线性映射获得；由$p_q$ 表示原本应当采样的坐标(这里和可变性卷积稍有出入)；因此$x(p_q+\\Delta p_{mqk})$ 表示在特征图中采样得到的token的二维坐标（当然这里也用到了双线性差值），用该坐标位置的token对应的key(需要经过线性映射)的key与value,与query进行注意力机制，而后得到对应的注意力权重$A_{mqk}$（当然原文中$A_{mqk}$ 也是由$z_q$ 线性映射后softmax得到的，是注意力的变体，不是传统的注意力机制）；最后再乘以权重参数$W_m^{\u0026rsquo;}$ (原文中这个是单位矩阵，费解)，最后再乘以不同注意力头分配的权重，得到注意力机制的结果。\n3.2多尺度可变性注意力模块(Multi-scale Deformable Attention Module) 以上提到的注意力机制可以很自然地应用于多尺度特征图中，公式如下：\n其中，m表示注意力头序号，k表示采样点序号，l表示特征图的尺度等级。\n特别需要说明的是，为了在不同尺度(当然这里可以理解为分辨率)下应用这个可变性注意力机制，我们需要进行采样时坐标的处理，因此这里将采样点二维坐标进行归一化$\\hat p_q \\in [0,1]^2$,则在不同特征图尺度下可以找到同一位置的点。之后为了在不同尺度下取的指定位置的$z_q$ 值，再通过$\\phi_l()$ 函数将$p_q$ 映射回原尺度得到坐标。\n3.3 Deformable Transformer Encoder 在编码器中，从ResNet的$C_3$ 到$C_5$ 阶段的输出中提取四个等级尺度$(L=4)$的特征图，$C_l$ 阶段的特征图比原图低 $2^l$ 倍，最低分辨率特征图是$C_6$,也就是$C_5$ 再通过步长为2的$3\\times3$ 卷积得到。编码器的输出是和输入相同分辨率的多尺度特征图，key和query元素都是多尺度特征图中的像素。对于每一个query,参考点就是它本身。\n为了表示尺度信息，类比transformer中的position embedding,在这里也加入了scale-level embedding,这个embedding是通过网络训练而成的。\n3.4 Deformable Transformer Decoder 实际是在学习检测框的特征\n解码器中有交叉注意力与自注意力，两种注意力的query都是object。在交叉注意力中，key来自编码器，object query从特征图中抽取特征。在自注意中，object query互相作用，这时key为object query本身。当然在这里只在交叉注意力之中，应用deformable attention，自注意力不变。对于每一个object query,参考点的坐标是根据object embedding通过一层可学习的线性映射得到的。\n因为多尺度可变形卷积是依据参考点来提取特征的，所以我们用检测头预测boundingbox作为相对于参考点的坐标偏移，参考点作为最初预测框的中心。因此，解码器的注意力机制会与预测框有很大的相关性。\n4.BoundingBox回归损失 4.1 L1损失 L1损失也即平均绝对误差(MAE)，顾名思义公式如下：\n$$ L1(y, \\hat{y}) = \\frac{1}{n} \\sum_{i=1}^{n} |y_i - \\hat{y}_i| $$\n其曲线分布如下：\n特点：\n导数为常量，不会有梯度爆炸问题； 对于离群点的惩罚是是固定的； 但是：\n在0处不可导 正因为导数为常量，对于较小的损失值也具有较大的梯度，缺乏自适应性 4.2 L2损失 也称均方误差(MSE)，一目了然公式如下：\n$$ L2(y, \\hat{y}) = \\frac{1}{n} \\sum_{i=1}^{n} (y_i - \\hat{y}_i)^2 $$\n其曲线如下：\n特点：\n出处连续，处处可导； 并且随着误差值减小，梯度也会减小，利于收敛 但是：\n当$y-f(x)$ 差值大于1时，平方项会放大误差，对离群点惩罚比较大 4.3 Smooth L1 即以上两种损失的联合，在误差小于1时为L2损失，大于1时为L1损失\n公式如下：\n$$ \\text{SmoothL1}(y, \\hat{y}) = \\begin{cases} 0.5 * (y - \\hat{y})^2 \u0026amp; \\text{if } |y - \\hat{y}| \u0026lt; 1 \\ |y - \\hat{y}| - 0.5 \u0026amp; \\text{otherwise} \\end{cases} $$\n曲线如下：\n特点：\n当误差过大，梯度不会过大 当误差比较小，梯度也会相应减小 实际上就是联合了以上两种函数的优点。\n5. IoU损失 5.1 IoU**(Intersection over Union)** 用于衡量模型预测的区域与真实区域之间的重叠程度\n即计算两个区域的交集面积与它们的并集面积之比。\nIoU损失的计算公式如下所示：\n$$ IoU = \\frac{{\\text{Intersection Area}}}{{\\text{Union Area}}} = \\frac{{\\text{TP}}}{{\\text{TP + FP + FN}}} $$\n其中：\nTP（True Positive）：真正例，模型正确预测的正样本数量。 FP（False Positive）：假正例，模型错误预测的正样本数量。 FN（False Negative）：假负例，模型未能正确预测的正样本数量。 实际上也可简单理解为交并比：\n$$ IoU = \\frac{{|A \\cap B|}}{{|A \\cup B|}} $$\nIoU损失越小，表示模型的预测与真实情况的重叠程度越大。\n由于IoU为比值形式，所以它具有一个很好的特性是，对尺度(scale)不敏感\n5.2 GIoU**(Generalized Intersection over Union)** 由于BBox中的回归损失对scale比较敏感，并且其优化与IoU损失的优化不是等价的，因此对IoU损失进行改进，在计算目标检测框的重叠程度时考虑了检测框的整体位置和大小关系，不仅仅是交并关系，从而设置为回归损失：\n$$ GIoU = IoU - \\frac{{|C- (A \\cup B)|}}{{|C|}} $$\n其中：\n$|C - (A \\cup B)|$ 表示外部包围框 C 减去 A和 B的并集的大小（即不相交的部分的大小）。 |C| 示外部包围框 C 的大小，同时包含了预测框和真实框的最小框的面积。 GIoU 将 IoU 的值减去了外部不相交部分与外部包围框的比例，不仅关注重叠区域，还关注非重叠区域，从而考虑了检测框的整体位置关系,能更好的反映两者的重合度。使得 GIoU 更能够准确地反映检测框的匹配情况。\n","permalink":"https://zqlqy.github.io/posts/deformabledetr/","summary":"DeformableDETR 1.DETR 1.1 简述 Detr将目标检测任务看作是集合预测问题，在每次将所有的object都做出预测，之后与GroundTruth进行二分图匹配，每一个object预测结果都会对应一个种类与位置(当然其中包含背景种类)；并且使用transformer来构建模型，对所有的objectquery来并行预测。\n相比较以往的目标检测模型，DETR主要有以下几个创新点：\n将目标检测任务看作是集合预测问题，并为此设计了损失函数，得到固定数量的object预测之后与真实值进行二分匹配，从而不需要以往的去重工作（如NMS） 使用transformer来并行预测与建模，不再需要先验知识(如anchor的设计) 总之，detr是首个真正的端到端目标检测模型，也是将transformer运用到目标检测任务中的首次尝试。\n1.2损失函数（Object detection set prediction loss） DETR每次得出固定数量$N$ 的预测结果，当然$N$ 需要大于在图片中出现的物体数量，之后得出这些预测结果与真实值之间的最佳二分匹配，得出最佳匹配的方法表示如下：\n其中，$y$ 代表所预测目标的真实值，当然其中包括物体的种类与位置；$\\hat y={\\hat y_i}{i=1}^{N}$ 表示对每个objectquery得到的预测结果,$\\sigma(i)$ 则表示对于第$i$ 个预测结果所匹配到的groundtruth的索引，$\\ell{match}(y_i,\\hat y_{\\sigma(i)})$ 表示二者之间的匹配成本。我们最终需要的使匹配成本最小的$\\sigma$ 。当然这里可以使用匈牙利算法。\n1.2.1匹配成本 这里的匹配成本同时考虑了物体的种类与位置，即$\\hat y = (c_i,b_i)$ ,其中$c_i$表示物体种类，$b_i \\in [0,1]^4$ 为包含ground box中心坐标与长、宽的向量。对于索引$\\sigma(i)$ 我们将该索引对应的预测结果分类为$c_i$ 的概率表示为$p_{\\sigma(i)}(c_i)$ ,将其预测的box表示为$\\hat b_{\\sigma (i)}$ ，因此可以将匹配成本函数定义为：$L_{match}(y_i, \\hat y_{\\sigma(i)}) =−1_{c_i\\not=\\emptyset}\\hat p_{\\sigma(i)}(c_i) + 1_{c_i\\not=\\emptyset} L_{box}(b_i, \\hat b_{\\sigma_i}(i))$ 。这样的过程与以往的目标检测算法中为anchor或者proposal分配真实值的工作效果相同，当然区别在与我们得到的是一一对应的匹配，不存在重复的问题。\n1.2.2 标记框损失(Bounding box loss) 因为本模型是直接做出对于box的预测的，所以会遇到不同尺度下损失的相对缩放。常用的$l_1$ 损失会跟随预测框的大小产生缩放，即使这两种预测框的错误程度是相同的。而IoU损失的尺度是不变的，因此这里将$l_1$ 损失与IoU损失做线性组合，成为我们需要的boxloss，如下：\n当然，其中$\\lambda_{iou}$ 与$\\lambda_{L_1}$ 都是超参数。\n1.2.3 损失函数 之后就可以定义匹配的损失函数如下：\n1.3 网络结构 (DETR architecture) 先上图","title":"DeformableDETR"},{"content":"到现在为止，共有三种重要的生成模型，GAN,VAE和Flow-based模型。他们在生成高质量样本的任务中表现很好，但也有各自的缺陷。GAN因为其对抗训练的本质，在训练中潜在的不确定性，在生成样本时缺乏多样化；VAE依赖替代损失(surrogate loss)；Flow-based模型必须使用特定的结构来构建可逆的变换。\nDiffusion来自于非平衡热力学的启发。他们定义了在扩散过程中缓慢地向数据中加入随机噪声的马尔科夫链，之后尝试去学习逆向扩散过程，来从噪声中塑造我们想要的样本。与VAE或者flow-based模型不同，扩散模型具有固定的步骤，并且其中的潜变量可以拥有高维度(与原始数据维度相同)。\n什么是扩散模型？ 一些基于扩散思想的模型paper如下：\ndiffusion probabilistic models (Sohl-Dickstein et al., 2015)\nnoise-conditioned score network ( NCSN ; Yang \u0026amp; Ermon, 2019)\nand denoising diffusion probabilistic models ( DDPM ; Ho et al. 2020)\n前向扩散过程 对于给定从真实分布中采样$x_0$\n","permalink":"https://zqlqy.github.io/posts/diffusion%E7%AE%80%E4%BB%8B/","summary":"到现在为止，共有三种重要的生成模型，GAN,VAE和Flow-based模型。他们在生成高质量样本的任务中表现很好，但也有各自的缺陷。GAN因为其对抗训练的本质，在训练中潜在的不确定性，在生成样本时缺乏多样化；VAE依赖替代损失(surrogate loss)；Flow-based模型必须使用特定的结构来构建可逆的变换。\nDiffusion来自于非平衡热力学的启发。他们定义了在扩散过程中缓慢地向数据中加入随机噪声的马尔科夫链，之后尝试去学习逆向扩散过程，来从噪声中塑造我们想要的样本。与VAE或者flow-based模型不同，扩散模型具有固定的步骤，并且其中的潜变量可以拥有高维度(与原始数据维度相同)。\n什么是扩散模型？ 一些基于扩散思想的模型paper如下：\ndiffusion probabilistic models (Sohl-Dickstein et al., 2015)\nnoise-conditioned score network ( NCSN ; Yang \u0026amp; Ermon, 2019)\nand denoising diffusion probabilistic models ( DDPM ; Ho et al. 2020)\n前向扩散过程 对于给定从真实分布中采样$x_0$","title":"Diffusion简介"},{"content":"#include \u0026lt;cstring\u0026gt; #include \u0026lt;valarray\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //宏定义声明 //实现词法分析所需 //宏定义各种符号类型 #define DIGIT 1 #define POINT 2 #define OTHER 3 #define POWER 4 #define PLUS 5 #define MINUS 6 # define ID 7 # define INT 8 # define REAL 9 # define LT 10 # define LE 11 # define EQ 12 # define NE 13 # define GT 14 # define GE 15 # define IS 16 # define PL 17 # define MI 18 # define MU 19 # define DI 20 # define AND 21 # define OR 22 # define NOT 23 # define STR 24 # define CHAR 25 # define OCT 26 # define HEX 27 # define LB 28 # define RB 29 # define NS 30 # define UCON 97 # define ClassOther 200 # define EndState -1 #define MAX_KEY_NUMBER 20 /*关键字的数量*/ #define KEY_WORD_END \u0026#34;#\u0026#34; /*关键字结束标记*/ //输出设置（为区分实验结果） int mode = 0; // 变量定义 // 实现词法分析所需 const int N=10000;// 够用 char *KeyWordTable[MAX_KEY_NUMBER]={\u0026#34;begin\u0026#34;,\u0026#34;end\u0026#34;, \u0026#34;const\u0026#34;,\u0026#34;var\u0026#34;,\u0026#34;if\u0026#34;, \u0026#34;else\u0026#34;,KEY_WORD_END};//关键词表 //实数分析 int w,n,p,e,d;//实数分析所需 int Class;//实数分析类别 int ICON;//实数分析 float FCON;//实数分析的值 static int CurrentState;//实数分析当前状态 //扫描用 int adx=1,ady=1;//当前读入的位置 char ch; //当前读入的字符，必须要设定这个全局变量，在回退之前检查一下是否为EOF,在scanner中为EOF不回退 char TOKEN[20];//每个读入单词 //实现语法分析所需 int sta[10010];//状态栈 int syb[10010];//符号栈 int mea[1010];//语义栈 int stat=0,sybt=0; int meat=0;//以上三栈的栈顶 int topsta;//状态栈顶,在action表中用 int inpsym;//输入符号串顶，在action表中用 //语法本身 char* action[200][200];//action表 int Goto[200][200];//goto表 string R1[100][2]= {{\u0026#34;S\u0026#34;,\u0026#34;E\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E+T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E-T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;T\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;}, {\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;F\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;(E)\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;i\u0026#34;}};//语法 char follow[300][50]; //实现语义分析所需 int idx=0;//每个键值对的索引（key,value） string valu[N];//每个单词的值 int cla[N];//每个单词的类型 int chra[N];//每个单词在语法中扮演的角色 int T[N]={}; int tt=1;//临时变量编号 //函数定义 //报错函数 void report_error(int errcla){ int k=0; char* str; switch (errcla){ case 1: str = \u0026#34;十六进制数表示错误\u0026#34;; break; case 2: str = \u0026#34;八进制数表示错误\u0026#34;; break; case 3: str = \u0026#34;字符型常量定义错误\u0026#34;; break; case 4: str = \u0026#34;非法运算符\u0026#34;; break; case 5: str = \u0026#34;未定义符号\u0026#34;; break; case 6: str=\u0026#34;语法错误\u0026#34;; k=1; break; case 7: str = \u0026#34;未找到表达式\u0026#34;; k=2; break; case 8: str = \u0026#34;不是算符优先文法\u0026#34;; k=2; break; case 11: str=\u0026#34;缺少运算分量\u0026#34;; k=2; break; case 12: str=\u0026#34;不匹配的右括号\u0026#34;; k=2; break; case 13: str=\u0026#34;缺少运算符\u0026#34;; k=2; break; case 14: str=\u0026#34;缺少右括号\u0026#34;; k=2; break; } if(!k){printf(\u0026#34;词法分析发生错误!错误位置：第%d行，第%d个字符；错误类型：%s\\n\u0026#34;,adx,ady-1,str);} else if (k==2) { printf(\u0026#34;语法分析发生错误！错误类型：%s, 错误位置：第%d行，第%d个字符\\n\u0026#34;, str, adx,ady); } return; } //实现语法分析所需 //自定义读入函数 char gc(FILE* fp,int index){//index是换行允许位 char ch =fgetc(fp); //printf(\u0026#34;%c \u0026#34;,ch); if(ch==\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;index){ adx++; ady=1; // // printf(\u0026#34;换行,%d\u0026#34;,adx); } else ady++; //printf(\u0026#34;(%d,%d)\\n\u0026#34;,adx,ady); return ch; } void myfseek(FILE* fp ,int off ,int whence ){ if(ch!=EOF){ fseek(fp,off,whence); ady+=off; } } //查找类别并输出函数 int lookup (char *token) { int n=0; while (strcmp(KeyWordTable[n], KEY_WORD_END)) /*strcmp比较两串是否相同，若相同返回0*/ { if (!strcmp(KeyWordTable[n], token)) /*比较token所指向的关键字和保留字表中哪个关键字相符*/ { return n+1; /*根据单词分类码表I，设置正确的关键字类别码，并返回此类别码的值*/ } n++; } return 7; /*单词不是关键字，而是标识符*/ } void out(int c, string val) { char* str; switch (c) { case 1: str = \u0026#34;BEGIN\u0026#34;; break; case 2: str = \u0026#34;END\u0026#34;; break; case 3: str = \u0026#34;CONST\u0026#34;; break; case 4: str = \u0026#34;VAR\u0026#34;; break; case 5: str = \u0026#34;IF\u0026#34;; break; case 6: str = \u0026#34;ELSE\u0026#34;; break; case 7: str = \u0026#34;ID\u0026#34;; break; case 8: str=\u0026#34;INT\u0026#34;; break; case 9: str = \u0026#34;REAL\u0026#34;; break; case 10: str = \u0026#34;LT\u0026#34;; break; case 11: str = \u0026#34;LE\u0026#34;; break; case 12: str = \u0026#34;EQ\u0026#34;; break; case 13: str = \u0026#34;NE\u0026#34;; break; case 14: str = \u0026#34;GT\u0026#34;; break; case 15: str=\u0026#34;GE\u0026#34;; break; case 16: str = \u0026#34;IS\u0026#34;; break; case 17: str = \u0026#34;PL\u0026#34;; break; case 18: str = \u0026#34;MI\u0026#34;; break; case 19: str = \u0026#34;MU\u0026#34;; break; case 20: str = \u0026#34;DI\u0026#34;; break; case 21: str = \u0026#34;AND\u0026#34;; break; case 22: str = \u0026#34;OR\u0026#34;; break; case 23: str = \u0026#34;NOT\u0026#34;; break; case 24: str = \u0026#34;STR\u0026#34;; break; case 25: str = \u0026#34;CHAR\u0026#34;; break; case 26: str = \u0026#34;OCT\u0026#34;; break; case 27: str = \u0026#34;HEX\u0026#34;; break; case 28: str = \u0026#34;LB\u0026#34;; break; case 29: str = \u0026#34;RB\u0026#34;; break; case 30: str = \u0026#34;NS\u0026#34;; break; } cla[idx] = c; valu[idx] = val; if(c!=LB\u0026amp;\u0026amp;c!=RB\u0026amp;\u0026amp;c!=PL\u0026amp;\u0026amp;c!=MI\u0026amp;\u0026amp;c!=MU\u0026amp;\u0026amp;c!=DI\u0026amp;\u0026amp;c!=NS){//不是运算符号 chra[idx] = \u0026#39;i\u0026#39;; } else { chra[idx] = c; } if(mode==1){ cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;val\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } } //实验给的没啥用函数 int HandleOtherWord (void) { return ClassOther; } int HandleError (void){ printf(\u0026#34;Error!\\n\u0026#34;); return 0; } int GetChar (FILE* fp) { int c; c = gc(fp,0); if (c != EOF) { if (isdigit(c)) { d = c - \u0026#39;0\u0026#39;; return DIGIT; } if (c == \u0026#39;.\u0026#39;) return POINT; if (c == \u0026#39;E\u0026#39; || c == \u0026#39;e\u0026#39;) return POWER; if (c == \u0026#39;+\u0026#39;) return PLUS; if (c == \u0026#39;-\u0026#39;) return MINUS; } return OTHER;//返回当前字符的类 } int EXCUTE (int state, int symbol) { switch (state) { case 0:switch (symbol) { case DIGIT: n=0;p=0;e=1;w=d;CurrentState=1;Class=UCON;break; case POINT: w=0;n=0;p=0;e=1;CurrentState=3;Class=UCON;break; default: HandleOtherWord( );Class=ClassOther; CurrentState=EndState; } break; case 1:switch (symbol) { case DIGIT: w=w*10+d;break; //CurrentState=1 case POINT: CurrentState=2;break; case POWER: CurrentState=4;break; default: ICON=w;CurrentState=EndState; } break; case 2:switch (symbol) { case DIGIT: n++;w=w*10+d;break; case POWER: CurrentState=4;break; default: FCON=w*pow(10,e*p-n);CurrentState=EndState; } break; case 3:switch (symbol) { case DIGIT: n++;w=w*10+d;CurrentState=2;break; default: HandleError( );CurrentState=EndState; } break; case 4:switch (symbol) { case DIGIT: p=p*10+d;CurrentState=6;break; case MINUS: e=-1;CurrentState=5;break; case PLUS: CurrentState=5;break; default: HandleError( );CurrentState=EndState; } break; case 5:switch (symbol) { case DIGIT: p=p*10+d;CurrentState=6;break; default: HandleError( );CurrentState=EndState; } break; case 6:switch (symbol) { case DIGIT:p=p*10+d;break; default: FCON=w*pow(10,e*p-n);CurrentState=EndState; } break; } return CurrentState; } int LEX (FILE* fp) { int ch; CurrentState=0; while (CurrentState!=EndState) { ch=GetChar(fp); EXCUTE (CurrentState,ch); } myfseek(fp,-1,1); return Class; } //拓展实验分析十六进制数所需 int ISABCDEF(char x){ int n=0; char al[20]={\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;#\u0026#39;}; while (al[n]!=\u0026#39;#\u0026#39;) /*strcmp比较两串是否相同，若相同返回0*/ { if (al[n]==x) { return 1; } n++; } return 0; /*单词不是关键字，而是标识符*/ } //扫描器与单个扫描 void scanner(FILE *fp) { int i, c; ch=gc(fp,0); if (isalpha (ch)) { TOKEN[0]=ch; ch=gc(fp,0); i=1;//初始化 while (isalnum (ch))//是否为字母或者数字 { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i]= \u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); c=lookup(TOKEN);//查找源程序， if(c==ID)out(c,TOKEN); else out(c,\u0026#34; \u0026#34;); } else if(isdigit(ch)) { //将数字部分读入token， TOKEN[0]=ch;i=1; if(ch==\u0026#39;0\u0026#39;){ ch=gc(fp,0); if(ch==\u0026#39;x\u0026#39;){ TOKEN[i]=ch; i++; ch=gc(fp,0); bool is=1; while(isalnum(ch)) { if(isalpha(ch)\u0026amp;\u0026amp;!ISABCDEF(ch)){ report_error(1); is=0; break; } TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i]=\u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); if(is){ c=HEX; out(c,TOKEN); } } else if(isdigit(ch)){ bool is=1; while(isdigit(ch)) { if(ch\u0026gt;=\u0026#39;8\u0026#39;){ report_error(2); is=0; break; } else { TOKEN[i]=ch; i++; ch=gc(fp,0); } } myfseek(fp,-1,1); TOKEN[i]= \u0026#39;\\0\u0026#39;; if(is){ c=OCT; out(c,TOKEN); } } else { TOKEN[i]=\u0026#39;\\0\u0026#39;; out(INT,TOKEN); } } else { ch=gc(fp,0); while(isdigit(ch)) { TOKEN[i]=ch; i++; ch=gc(fp,0); } if(ch==\u0026#39;.\u0026#39;||ch==\u0026#39;E\u0026#39;||ch==\u0026#39;e\u0026#39;){ myfseek(fp,-i-1,1); LEX(fp); c=REAL; if(mode==1){ cout\u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; \u0026#34;REAL,\u0026#34; \u0026lt;\u0026lt;FCON\u0026lt;\u0026lt; \u0026#34;)\u0026#34;\u0026lt;\u0026lt; endl; } //cout\u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; \u0026#34;REAL,\u0026#34; \u0026lt;\u0026lt;FCON\u0026lt;\u0026lt; \u0026#34;)\u0026#34;\u0026lt;\u0026lt; endl; cla[idx] = REAL; valu[idx] = to_string(FCON); chra[idx] = \u0026#39;i\u0026#39;; //printf(\u0026#34;(REAL,%.12lf %e %g )\\n\u0026#34;,FCON);//添加范围识别 } else{ TOKEN[i]= \u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); c=INT; out(c,TOKEN); } } } else if(ch==\u0026#39;\\\u0026#34;\u0026#39;){ TOKEN[0]=ch; ch=gc(fp,0); i=1; while(ch!=\u0026#39;\\\u0026#34;\u0026#39;) { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i++]=ch;TOKEN[i]=\u0026#39;\\0\u0026#39;; c=STR; out(c,TOKEN); } else if(ch==\u0026#39;\\\u0026#39;\u0026#39;){ TOKEN[0]=ch; ch=gc(fp,0); i=1; while(ch!=\u0026#39;\\\u0026#39;\u0026#39;) { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i++]=ch;TOKEN[i]=\u0026#39;\\0\u0026#39;; if(strlen(TOKEN)\u0026gt;3)report_error(3); else { c=CHAR; out(c,TOKEN); } } else switch(ch) { case \u0026#39;\u0026lt;\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=LE;out(LE,\u0026#34; \u0026#34;);} else if(ch==\u0026#39;\u0026gt;\u0026#39;) {c=NE;out (NE,\u0026#34; \u0026#34;);} else { myfseek (fp,-1,1); c=LT; out (LT,\u0026#34; \u0026#34;); } break; case \u0026#39;=\u0026#39;: c=EQ; out(EQ, \u0026#34; \u0026#34;); break; case \u0026#39;\u0026gt;\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=GE;out(GE,\u0026#34; \u0026#34;);} else { myfseek(fp,-1,1); c=GT; out(GT,\u0026#34; \u0026#34;); } break; case \u0026#39;:\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=IS;out(IS,\u0026#34; \u0026#34;);} else{ myfseek(fp,-1,1); report_error(4); } break; case \u0026#39;+\u0026#39;: c=PL; out(PL, \u0026#34; \u0026#34;); break; case \u0026#39;-\u0026#39;: c=MI; out(MI, \u0026#34; \u0026#34;); break; case \u0026#39;*\u0026#39;: c=MU; out(MU, \u0026#34; \u0026#34;); break; case \u0026#39;/\u0026#39;: c=DI; out(DI, \u0026#34; \u0026#34;); break; case \u0026#39;\u0026amp;\u0026#39;: c=AND; out(AND, \u0026#34; \u0026#34;); break; case \u0026#39;|\u0026#39;: c=OR; out(OR, \u0026#34; \u0026#34;); break; case \u0026#39;!\u0026#39;: c=NOT; out(NOT, \u0026#34; \u0026#34;); break; case \u0026#39;(\u0026#39;: c= LB ; out( LB ,\u0026#34; \u0026#34;); break; case \u0026#39;)\u0026#39;: c = RB; out(RB,\u0026#34; \u0026#34;); break; case \u0026#39;#\u0026#39;: c = NS; out(NS,\u0026#34; \u0026#34;); break; default: report_error(5); break; } return ; } int scan(FILE* test){//向前读一个单词，帮助避开了空格，回车等符号 char c; if((c=gc(test,1))!=EOF){//试探是否到了文档尾 while(c==\u0026#39; \u0026#39;||c==\u0026#39;\\t\u0026#39;||c==\u0026#39;\\n\u0026#39;){//越过无意义符号 c= gc(test,1); } if(c!=EOF){//防止空格回车结尾 myfseek(test,-1,1); scanner(test); } else {//有特殊符号到了文档尾 cla[idx] = NS; valu[idx] = \u0026#34; \u0026#34;; chra[idx] = NS; } } else {//没有特殊符号也到了文档尾 cla[idx] = NS; valu[idx] = \u0026#34; \u0026#34;; chra[idx] = NS; } return idx++; } //实现语法分析所需 void gen(int r,FILE* fp){//计算值并且输出四元式,给出表达式编号 string g2 = R1[r][1]; int len = g2.length(); int k1,k2; string x1,x2; char sym; if(len==1) {//iTEF T[idx]=T[mea[meat]];//传递中间变量位置 valu[idx] = valu[mea[meat]]; } else if(len==3){//(E)，不分配新的空间 if(chra[mea[meat]]==RB){ T[idx]=tt-1; valu[idx] = valu[mea[meat]]; } else {//算数,分配新的空间 int sy; sy = chra[mea[meat-1]]; k1=T[mea[meat-2]];//为输出四元式的参数1 k2=T[mea[meat]];//输出四元式的参数2 switch(sy){ case PL: sym=\u0026#39;+\u0026#39;; break; case MI: sym=\u0026#39;-\u0026#39;; break; case DI: sym=\u0026#39;/\u0026#39;; break; case MU: sym = \u0026#39;*\u0026#39;; break; } if(k1==-1){ x1=valu[mea[meat-2]]; } else x1 = \u0026#34;T\u0026#34;+ to_string(k1); if(k2==-1){ x2=valu[mea[meat]]; } else x2 = \u0026#34;T\u0026#34;+ to_string(k2); T[idx]=tt++; if(mode==3){ cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt;sym\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;x1\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;x2\u0026lt;\u0026lt;\u0026#34;,T\u0026#34;\u0026lt;\u0026lt;T[idx]\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } fprintf(fp,\u0026#34;(%c,%s,%s,T%d)\\n\u0026#34;,sym,x1.c_str(),x2.c_str(),T[idx]); } } return ; } void slr_init(){ for (int i = 0; i \u0026lt; 200; ++i) { for (int j = 0; j \u0026lt; 200; ++j) { action[i][j] = NULL; } } action[0][LB]=\u0026#34;S4\u0026#34;; action[0][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[1][PL] = \u0026#34;S6\u0026#34;; action[1][MI] = \u0026#34;S7\u0026#34;; action[1][NS] = \u0026#34;Acc\u0026#34;; action[2][RB] = action[2][PL]=action[2][MI]=action[2][NS] = \u0026#34;R3\u0026#34;; action[2][MU] = \u0026#34;S8\u0026#34;; action[2][DI] = \u0026#34;S9\u0026#34;; action[3][RB] =action[3][PL] =action[3][MI] =action[3][MU] =action[3][DI] =action[3][NS] =\u0026#34;R6\u0026#34;; action[4][LB] = \u0026#34;S4\u0026#34;; action[4][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[5][RB] =action[5][PL] =action[5][MI] =action[5][MU] =action[5][DI] =action[5][NS] =\u0026#34;R8\u0026#34;; action[6][LB] = action[7][LB] = action[8][LB] = action[9][LB] = \u0026#34;S4\u0026#34;; action[6][\u0026#39;i\u0026#39;] =action[7][\u0026#39;i\u0026#39;] =action[8][\u0026#39;i\u0026#39;] =action[9][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[10][RB] = \u0026#34;S15\u0026#34;; action[10][PL] =\u0026#34;S6\u0026#34;; action[10][MI] =\u0026#34;S7\u0026#34;; action[11][RB] =action[11][PL] =action[11][MI] =action[11][NS]=\u0026#34;R1\u0026#34;; action[12][RB] =action[12][PL] =action[12][MI] =action[12][NS]=\u0026#34;R2\u0026#34;; action[11][MU] =action[12][MU] =\u0026#34;S8\u0026#34;; action[11][DI] =action[12][DI] =\u0026#34;S9\u0026#34;; action[13][RB] =action[13][PL] =action[13][MI] =action[13][MU] =action[13][DI] =action[13][NS] =\u0026#34;R4\u0026#34;; action[14][RB] =action[14][PL] =action[14][MI] =action[14][MU] =action[14][DI] =action[14][NS] =\u0026#34;R5\u0026#34;; action[15][RB] =action[15][PL] =action[15][MI] =action[15][MU] =action[15][DI] =action[15][NS] =\u0026#34;R7\u0026#34;; //错误分析类型 action[1][LB]=action[2][LB]=action[3][LB]=action[5][LB]=action[10][LB]=action[11][LB]=action[12][LB]=action[13][LB]=action[14][LB]=action[15][LB]=\u0026#34;e3\u0026#34;; action[0][RB]=action[1][RB]=action[4][RB]=action[6][RB]=action[7][RB]=action[8][RB]=action[9][RB]=\u0026#34;e2\u0026#34;; action[0][PL]=action[4][PL]=action[6][PL]=action[7][PL]=action[8][PL]=action[9][PL]=\u0026#34;e1\u0026#34;; action[0][MI]=action[4][MI]=action[6][MI]=action[7][MI]=action[8][MI]=action[9][MI]=\u0026#34;e1\u0026#34;; action[0][MU]=action[4][MU]=action[6][MU]=action[7][MU]=action[8][MU]=action[9][MU]=action[1][MU]=action[10][MU]=\u0026#34;e1\u0026#34;; action[0][DI]=action[4][DI]=action[6][DI]=action[7][DI]=action[8][DI]=action[9][DI]=action[1][DI]=action[10][DI]=\u0026#34;e1\u0026#34;; action[1][\u0026#39;i\u0026#39;]=action[2][\u0026#39;i\u0026#39;]=action[3][\u0026#39;i\u0026#39;]=action[5][\u0026#39;i\u0026#39;]=action[10][\u0026#39;i\u0026#39;]=action[11][\u0026#39;i\u0026#39;]=action[12][\u0026#39;i\u0026#39;]=action[13][\u0026#39;i\u0026#39;]=action[14][\u0026#39;i\u0026#39;]=action[15][\u0026#39;i\u0026#39;]=\u0026#34;e3\u0026#34;; action[0][NS]=action[4][NS]=action[6][NS]=action[7][NS]=action[8][NS]=action[9][NS]=\u0026#34;e1\u0026#34;; action[10][NS]=\u0026#34;e4\u0026#34;; Goto[0][\u0026#39;E\u0026#39;] = 1; Goto[0][\u0026#39;T\u0026#39;] = 2; Goto[0][\u0026#39;F\u0026#39;] = 3; Goto[4][\u0026#39;E\u0026#39;] = 10; Goto[4][\u0026#39;T\u0026#39;] = 2; Goto[4][\u0026#39;F\u0026#39;] = 3; Goto[6][\u0026#39;T\u0026#39;] = 11; Goto[6][\u0026#39;F\u0026#39;] = 3; Goto[7][\u0026#39;T\u0026#39;] = 12; Goto[7][\u0026#39;F\u0026#39;] = 3; Goto[8][\u0026#39;F\u0026#39;] = 13; Goto[9][\u0026#39;F\u0026#39;]= 14; strcpy(follow[\u0026#39;E\u0026#39;],\u0026#34;#)+-\u0026#34;); strcpy(follow[\u0026#39;T\u0026#39;],\u0026#34;#)+_*/\u0026#34;); strcpy(follow[\u0026#39;F\u0026#39;],\u0026#34;#)+_*/\u0026#34;); sta[++stat]=0; syb[++sybt]=NS; } void superSLR1(FILE *fp){ printf(\u0026#34;开始slr分析：\\n\u0026#34;); slr_init(); string str;//存储每一步的表达式 bool x=true;//合法位 int index;//登记位 index = scan(fp); topsta = sta[stat];//状态栈 inpsym = chra[index];//符号栈 str=action[topsta][inpsym];//对应公式 FILE * result = fopen(\u0026#34;/home/zql/CLionProjects/cpex/result.txt\u0026#34;,\u0026#34;w\u0026#34;); fputs(\u0026#34;实验三中间代码生成如下：\\n\u0026#34;,result); while(str!=\u0026#34;Acc\u0026#34;){ if(str[0]==\u0026#39;S\u0026#39;){ int num; if(str.length()==2) num = str[1]-\u0026#39;0\u0026#39;; else if(str.length()==3)num=(str[1]-\u0026#39;0\u0026#39;)*10+str[2]-\u0026#39;0\u0026#39;; mea[++meat] = index;//当前符号入语义栈 if(chra[index]==\u0026#39;i\u0026#39;)T[index]=-1;//如果是数值，保留存储位置 //下一个状态入状态栈，不会出错 sta[++stat] = num; //读入下一个符号，可能会读到错误的非终结符号 index = scan(fp); //入符号栈 syb[++sybt] = chra[index]; if(mode==2){ printf(\u0026#34;移进操作, %d入状态栈, %d入符号栈, 输入串首为%d\\n\u0026#34;,num,syb[sybt],chra[index]); } } else if(str[0]==\u0026#39;R\u0026#39;){ int num = str[1]-\u0026#39;0\u0026#39;;//表达式编号 string r = R1[num][1]; if(mode==2){ cout\u0026lt;\u0026lt;\u0026#34;归约操作, 根据R\u0026#34;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;\u0026#34;, 表达式为\u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; } int len = r.length(); stat-=len; sybt-=len; gen(num,result);//计算并且生成四元式 meat-=len; topsta = sta[stat]; syb[++sybt]=R1[num][0][0];//规约 if(mode==2){ printf(\u0026#34; 规约为的非终结符号%c，入符号栈,\u0026#34;,syb[sybt]); } sta[++stat]=Goto[topsta][syb[sybt]]; mea[++meat] = idx; if(mode==2){ printf(\u0026#34; 规约后%d入状态栈\\n\u0026#34;,sta[stat] ); } idx++; } else if (str[0]==\u0026#39;e\u0026#39;){ //说明按照str中的位置找到的错误，则当前符号栈顶的符号是错误的 int num= str[1]-\u0026#39;0\u0026#39;; report_error(num+10); if(num==4)break; x=false; // 跳过当前的终结符号，将当前状态和下一个终结符号组合，寻找下一个表达式 index=scan(fp); syb[sybt] = chra[index]; } //查表 topsta = sta[stat]; inpsym = chra[index]; str=action[topsta][inpsym]; } if(x)printf(\u0026#34;合法!\\n\u0026#34;); return ; } //主函数 int main() { printf(\u0026#34;请选择输出结果类型(查看实验一结果请输入1，类推):\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;mode); FILE* test = fopen(\u0026#34;/home/zql/CLionProjects/cpex/text\u0026#34;,\u0026#34;r\u0026#34;); superSLR1(test); fclose(test); return 0; } ","permalink":"https://zqlqy.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/","summary":"#include \u0026lt;cstring\u0026gt; #include \u0026lt;valarray\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //宏定义声明 //实现词法分析所需 //宏定义各种符号类型 #define DIGIT 1 #define POINT 2 #define OTHER 3 #define POWER 4 #define PLUS 5 #define MINUS 6 # define ID 7 # define INT 8 # define REAL 9 # define LT 10 # define LE 11 # define EQ 12 # define NE 13 # define GT 14 # define GE 15 # define IS 16 # define PL 17 # define MI 18 # define MU 19 # define DI 20 # define AND 21 # define OR 22 # define NOT 23 # define STR 24 # define CHAR 25 # define OCT 26 # define HEX 27 # define LB 28 # define RB 29 # define NS 30 # define UCON 97 # define ClassOther 200 # define EndState -1 #define MAX_KEY_NUMBER 20 /*关键字的数量*/ #define KEY_WORD_END \u0026#34;#\u0026#34; /*关键字结束标记*/ //输出设置（为区分实验结果） int mode = 0; // 变量定义 // 实现词法分析所需 const int N=10000;// 够用 char *KeyWordTable[MAX_KEY_NUMBER]={\u0026#34;begin\u0026#34;,\u0026#34;end\u0026#34;, \u0026#34;const\u0026#34;,\u0026#34;var\u0026#34;,\u0026#34;if\u0026#34;, \u0026#34;else\u0026#34;,KEY_WORD_END};//关键词表 //实数分析 int w,n,p,e,d;//实数分析所需 int Class;//实数分析类别 int ICON;//实数分析 float FCON;//实数分析的值 static int CurrentState;//实数分析当前状态 //扫描用 int adx=1,ady=1;//当前读入的位置 char ch; //当前读入的字符，必须要设定这个全局变量，在回退之前检查一下是否为EOF,在scanner中为EOF不回退 char TOKEN[20];//每个读入单词 //实现语法分析所需 int sta[10010];//状态栈 int syb[10010];//符号栈 int mea[1010];//语义栈 int stat=0,sybt=0; int meat=0;//以上三栈的栈顶 int topsta;//状态栈顶,在action表中用 int inpsym;//输入符号串顶，在action表中用 //语法本身 char* action[200][200];//action表 int Goto[200][200];//goto表 string R1[100][2]= {{\u0026#34;S\u0026#34;,\u0026#34;E\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E+T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E-T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;T\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;}, {\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;F\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;(E)\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;i\u0026#34;}};//语法 char follow[300][50]; //实现语义分析所需 int idx=0;//每个键值对的索引（key,value） string valu[N];//每个单词的值 int cla[N];//每个单词的类型 int chra[N];//每个单词在语法中扮演的角色 int T[N]={}; int tt=1;//临时变量编号 //函数定义 //报错函数 void report_error(int errcla){ int k=0; char* str; switch (errcla){ case 1: str = \u0026#34;十六进制数表示错误\u0026#34;; break; case 2: str = \u0026#34;八进制数表示错误\u0026#34;; break; case 3: str = \u0026#34;字符型常量定义错误\u0026#34;; break; case 4: str = \u0026#34;非法运算符\u0026#34;; break; case 5: str = \u0026#34;未定义符号\u0026#34;; break; case 6: str=\u0026#34;语法错误\u0026#34;; k=1; break; case 7: str = \u0026#34;未找到表达式\u0026#34;; k=2; break; case 8: str = \u0026#34;不是算符优先文法\u0026#34;; k=2; break; case 11: str=\u0026#34;缺少运算分量\u0026#34;; k=2; break; case 12: str=\u0026#34;不匹配的右括号\u0026#34;; k=2; break; case 13: str=\u0026#34;缺少运算符\u0026#34;; k=2; break; case 14: str=\u0026#34;缺少右括号\u0026#34;; k=2; break; } if(!","title":"编译原理实验"}]