[{"content":"到现在为止，共有三种重要的生成模型，GAN,VAE和Flow-based模型。他们在生成高质量样本的任务中表现很好，但也有各自的缺陷。GAN因为其对抗训练的本质，在训练中潜在的不确定性，在生成样本时缺乏多样化；VAE依赖替代损失(surrogate loss)；Flow-based模型必须使用特定的结构来构建可逆的变换。\nDiffusion来自于非平衡热力学的启发。他们定义了在扩散过程中缓慢地向数据中加入随机噪声的马尔科夫链，之后尝试去学习逆向扩散过程，来从噪声中塑造我们想要的样本。与VAE或者flow-based模型不同，扩散模型具有固定的步骤，并且其中的潜变量可以拥有高维度(与原始数据维度相同)。\n什么是扩散模型？ 一些基于扩散思想的模型paper如下：\ndiffusion probabilistic models (Sohl-Dickstein et al., 2015)\nnoise-conditioned score network ( NCSN ; Yang \u0026amp; Ermon, 2019)\nand denoising diffusion probabilistic models ( DDPM ; Ho et al. 2020)\n前向扩散过程 对于给定从真实分布中采样的 $𝑥_0∼𝑞(𝑥)$\n","permalink":"https://zqlqy.github.io/posts/diffusion%E7%AE%80%E4%BB%8B/","summary":"到现在为止，共有三种重要的生成模型，GAN,VAE和Flow-based模型。他们在生成高质量样本的任务中表现很好，但也有各自的缺陷。GAN因为其对抗训练的本质，在训练中潜在的不确定性，在生成样本时缺乏多样化；VAE依赖替代损失(surrogate loss)；Flow-based模型必须使用特定的结构来构建可逆的变换。\nDiffusion来自于非平衡热力学的启发。他们定义了在扩散过程中缓慢地向数据中加入随机噪声的马尔科夫链，之后尝试去学习逆向扩散过程，来从噪声中塑造我们想要的样本。与VAE或者flow-based模型不同，扩散模型具有固定的步骤，并且其中的潜变量可以拥有高维度(与原始数据维度相同)。\n什么是扩散模型？ 一些基于扩散思想的模型paper如下：\ndiffusion probabilistic models (Sohl-Dickstein et al., 2015)\nnoise-conditioned score network ( NCSN ; Yang \u0026amp; Ermon, 2019)\nand denoising diffusion probabilistic models ( DDPM ; Ho et al. 2020)\n前向扩散过程 对于给定从真实分布中采样的 $𝑥_0∼𝑞(𝑥)$","title":"Diffusion简介"},{"content":" #include \u0026lt;cstring\u0026gt; #include \u0026lt;valarray\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //宏定义声明 //实现词法分析所需 //宏定义各种符号类型 #define DIGIT 1 #define POINT 2 #define OTHER 3 #define POWER 4 #define PLUS 5 #define MINUS 6 # define ID 7 # define INT 8 # define REAL 9 # define LT 10 # define LE 11 # define EQ 12 # define NE 13 # define GT 14 # define GE 15 # define IS 16 # define PL 17 # define MI 18 # define MU 19 # define DI 20 # define AND 21 # define OR 22 # define NOT 23 # define STR 24 # define CHAR 25 # define OCT 26 # define HEX 27 # define LB 28 # define RB 29 # define NS 30 # define UCON 97 # define ClassOther 200 # define EndState -1 #define MAX_KEY_NUMBER 20 /*关键字的数量*/ #define KEY_WORD_END \u0026#34;#\u0026#34; /*关键字结束标记*/ //输出设置（为区分实验结果） int mode = 0; // 变量定义 // 实现词法分析所需 const int N=10000;// 够用 char *KeyWordTable[MAX_KEY_NUMBER]={\u0026#34;begin\u0026#34;,\u0026#34;end\u0026#34;, \u0026#34;const\u0026#34;,\u0026#34;var\u0026#34;,\u0026#34;if\u0026#34;, \u0026#34;else\u0026#34;,KEY_WORD_END};//关键词表 //实数分析 int w,n,p,e,d;//实数分析所需 int Class;//实数分析类别 int ICON;//实数分析 float FCON;//实数分析的值 static int CurrentState;//实数分析当前状态 //扫描用 int adx=1,ady=1;//当前读入的位置 char ch; //当前读入的字符，必须要设定这个全局变量，在回退之前检查一下是否为EOF,在scanner中为EOF不回退 char TOKEN[20];//每个读入单词 //实现语法分析所需 int sta[10010];//状态栈 int syb[10010];//符号栈 int mea[1010];//语义栈 int stat=0,sybt=0; int meat=0;//以上三栈的栈顶 int topsta;//状态栈顶,在action表中用 int inpsym;//输入符号串顶，在action表中用 //语法本身 char* action[200][200];//action表 int Goto[200][200];//goto表 string R1[100][2]= {{\u0026#34;S\u0026#34;,\u0026#34;E\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E+T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E-T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;T\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;}, {\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;F\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;(E)\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;i\u0026#34;}};//语法 char follow[300][50]; //实现语义分析所需 int idx=0;//每个键值对的索引（key,value） string valu[N];//每个单词的值 int cla[N];//每个单词的类型 int chra[N];//每个单词在语法中扮演的角色 int T[N]={}; int tt=1;//临时变量编号 //函数定义 //报错函数 void report_error(int errcla){ int k=0; char* str; switch (errcla){ case 1: str = \u0026#34;十六进制数表示错误\u0026#34;; break; case 2: str = \u0026#34;八进制数表示错误\u0026#34;; break; case 3: str = \u0026#34;字符型常量定义错误\u0026#34;; break; case 4: str = \u0026#34;非法运算符\u0026#34;; break; case 5: str = \u0026#34;未定义符号\u0026#34;; break; case 6: str=\u0026#34;语法错误\u0026#34;; k=1; break; case 7: str = \u0026#34;未找到表达式\u0026#34;; k=2; break; case 8: str = \u0026#34;不是算符优先文法\u0026#34;; k=2; break; case 11: str=\u0026#34;缺少运算分量\u0026#34;; k=2; break; case 12: str=\u0026#34;不匹配的右括号\u0026#34;; k=2; break; case 13: str=\u0026#34;缺少运算符\u0026#34;; k=2; break; case 14: str=\u0026#34;缺少右括号\u0026#34;; k=2; break; } if(!k){printf(\u0026#34;词法分析发生错误!错误位置：第%d行，第%d个字符；错误类型：%s\\n\u0026#34;,adx,ady-1,str);} else if (k==2) { printf(\u0026#34;语法分析发生错误！错误类型：%s, 错误位置：第%d行，第%d个字符\\n\u0026#34;, str, adx,ady); } return; } //实现语法分析所需 //自定义读入函数 char gc(FILE* fp,int index){//index是换行允许位 char ch =fgetc(fp); //printf(\u0026#34;%c \u0026#34;,ch); if(ch==\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;index){ adx++; ady=1; // // printf(\u0026#34;换行,%d\u0026#34;,adx); } else ady++; //printf(\u0026#34;(%d,%d)\\n\u0026#34;,adx,ady); return ch; } void myfseek(FILE* fp ,int off ,int whence ){ if(ch!=EOF){ fseek(fp,off,whence); ady+=off; } } //查找类别并输出函数 int lookup (char *token) { int n=0; while (strcmp(KeyWordTable[n], KEY_WORD_END)) /*strcmp比较两串是否相同，若相同返回0*/ { if (!strcmp(KeyWordTable[n], token)) /*比较token所指向的关键字和保留字表中哪个关键字相符*/ { return n+1; /*根据单词分类码表I，设置正确的关键字类别码，并返回此类别码的值*/ } n++; } return 7; /*单词不是关键字，而是标识符*/ } void out(int c, string val) { char* str; switch (c) { case 1: str = \u0026#34;BEGIN\u0026#34;; break; case 2: str = \u0026#34;END\u0026#34;; break; case 3: str = \u0026#34;CONST\u0026#34;; break; case 4: str = \u0026#34;VAR\u0026#34;; break; case 5: str = \u0026#34;IF\u0026#34;; break; case 6: str = \u0026#34;ELSE\u0026#34;; break; case 7: str = \u0026#34;ID\u0026#34;; break; case 8: str=\u0026#34;INT\u0026#34;; break; case 9: str = \u0026#34;REAL\u0026#34;; break; case 10: str = \u0026#34;LT\u0026#34;; break; case 11: str = \u0026#34;LE\u0026#34;; break; case 12: str = \u0026#34;EQ\u0026#34;; break; case 13: str = \u0026#34;NE\u0026#34;; break; case 14: str = \u0026#34;GT\u0026#34;; break; case 15: str=\u0026#34;GE\u0026#34;; break; case 16: str = \u0026#34;IS\u0026#34;; break; case 17: str = \u0026#34;PL\u0026#34;; break; case 18: str = \u0026#34;MI\u0026#34;; break; case 19: str = \u0026#34;MU\u0026#34;; break; case 20: str = \u0026#34;DI\u0026#34;; break; case 21: str = \u0026#34;AND\u0026#34;; break; case 22: str = \u0026#34;OR\u0026#34;; break; case 23: str = \u0026#34;NOT\u0026#34;; break; case 24: str = \u0026#34;STR\u0026#34;; break; case 25: str = \u0026#34;CHAR\u0026#34;; break; case 26: str = \u0026#34;OCT\u0026#34;; break; case 27: str = \u0026#34;HEX\u0026#34;; break; case 28: str = \u0026#34;LB\u0026#34;; break; case 29: str = \u0026#34;RB\u0026#34;; break; case 30: str = \u0026#34;NS\u0026#34;; break; } cla[idx] = c; valu[idx] = val; if(c!=LB\u0026amp;\u0026amp;c!=RB\u0026amp;\u0026amp;c!=PL\u0026amp;\u0026amp;c!=MI\u0026amp;\u0026amp;c!=MU\u0026amp;\u0026amp;c!=DI\u0026amp;\u0026amp;c!=NS){//不是运算符号 chra[idx] = \u0026#39;i\u0026#39;; } else { chra[idx] = c; } if(mode==1){ cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;val\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } } //实验给的没啥用函数 int HandleOtherWord (void) { return ClassOther; } int HandleError (void){ printf(\u0026#34;Error!\\n\u0026#34;); return 0; } int GetChar (FILE* fp) { int c; c = gc(fp,0); if (c != EOF) { if (isdigit(c)) { d = c - \u0026#39;0\u0026#39;; return DIGIT; } if (c == \u0026#39;.\u0026#39;) return POINT; if (c == \u0026#39;E\u0026#39; || c == \u0026#39;e\u0026#39;) return POWER; if (c == \u0026#39;+\u0026#39;) return PLUS; if (c == \u0026#39;-\u0026#39;) return MINUS; } return OTHER;//返回当前字符的类 } int EXCUTE (int state, int symbol) { switch (state) { case 0:switch (symbol) { case DIGIT: n=0;p=0;e=1;w=d;CurrentState=1;Class=UCON;break; case POINT: w=0;n=0;p=0;e=1;CurrentState=3;Class=UCON;break; default: HandleOtherWord( );Class=ClassOther; CurrentState=EndState; } break; case 1:switch (symbol) { case DIGIT: w=w*10+d;break; //CurrentState=1 case POINT: CurrentState=2;break; case POWER: CurrentState=4;break; default: ICON=w;CurrentState=EndState; } break; case 2:switch (symbol) { case DIGIT: n++;w=w*10+d;break; case POWER: CurrentState=4;break; default: FCON=w*pow(10,e*p-n);CurrentState=EndState; } break; case 3:switch (symbol) { case DIGIT: n++;w=w*10+d;CurrentState=2;break; default: HandleError( );CurrentState=EndState; } break; case 4:switch (symbol) { case DIGIT: p=p*10+d;CurrentState=6;break; case MINUS: e=-1;CurrentState=5;break; case PLUS: CurrentState=5;break; default: HandleError( );CurrentState=EndState; } break; case 5:switch (symbol) { case DIGIT: p=p*10+d;CurrentState=6;break; default: HandleError( );CurrentState=EndState; } break; case 6:switch (symbol) { case DIGIT:p=p*10+d;break; default: FCON=w*pow(10,e*p-n);CurrentState=EndState; } break; } return CurrentState; } int LEX (FILE* fp) { int ch; CurrentState=0; while (CurrentState!=EndState) { ch=GetChar(fp); EXCUTE (CurrentState,ch); } myfseek(fp,-1,1); return Class; } //拓展实验分析十六进制数所需 int ISABCDEF(char x){ int n=0; char al[20]={\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;#\u0026#39;}; while (al[n]!=\u0026#39;#\u0026#39;) /*strcmp比较两串是否相同，若相同返回0*/ { if (al[n]==x) { return 1; } n++; } return 0; /*单词不是关键字，而是标识符*/ } //扫描器与单个扫描 void scanner(FILE *fp) { int i, c; ch=gc(fp,0); if (isalpha (ch)) { TOKEN[0]=ch; ch=gc(fp,0); i=1;//初始化 while (isalnum (ch))//是否为字母或者数字 { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i]= \u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); c=lookup(TOKEN);//查找源程序， if(c==ID)out(c,TOKEN); else out(c,\u0026#34; \u0026#34;); } else if(isdigit(ch)) { //将数字部分读入token， TOKEN[0]=ch;i=1; if(ch==\u0026#39;0\u0026#39;){ ch=gc(fp,0); if(ch==\u0026#39;x\u0026#39;){ TOKEN[i]=ch; i++; ch=gc(fp,0); bool is=1; while(isalnum(ch)) { if(isalpha(ch)\u0026amp;\u0026amp;!ISABCDEF(ch)){ report_error(1); is=0; break; } TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i]=\u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); if(is){ c=HEX; out(c,TOKEN); } } else if(isdigit(ch)){ bool is=1; while(isdigit(ch)) { if(ch\u0026gt;=\u0026#39;8\u0026#39;){ report_error(2); is=0; break; } else { TOKEN[i]=ch; i++; ch=gc(fp,0); } } myfseek(fp,-1,1); TOKEN[i]= \u0026#39;\\0\u0026#39;; if(is){ c=OCT; out(c,TOKEN); } } else { TOKEN[i]=\u0026#39;\\0\u0026#39;; out(INT,TOKEN); } } else { ch=gc(fp,0); while(isdigit(ch)) { TOKEN[i]=ch; i++; ch=gc(fp,0); } if(ch==\u0026#39;.\u0026#39;||ch==\u0026#39;E\u0026#39;||ch==\u0026#39;e\u0026#39;){ myfseek(fp,-i-1,1); LEX(fp); c=REAL; if(mode==1){ cout\u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; \u0026#34;REAL,\u0026#34; \u0026lt;\u0026lt;FCON\u0026lt;\u0026lt; \u0026#34;)\u0026#34;\u0026lt;\u0026lt; endl; } //cout\u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; \u0026#34;REAL,\u0026#34; \u0026lt;\u0026lt;FCON\u0026lt;\u0026lt; \u0026#34;)\u0026#34;\u0026lt;\u0026lt; endl; cla[idx] = REAL; valu[idx] = to_string(FCON); chra[idx] = \u0026#39;i\u0026#39;; //printf(\u0026#34;(REAL,%.12lf %e %g )\\n\u0026#34;,FCON);//添加范围识别 } else{ TOKEN[i]= \u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); c=INT; out(c,TOKEN); } } } else if(ch==\u0026#39;\\\u0026#34;\u0026#39;){ TOKEN[0]=ch; ch=gc(fp,0); i=1; while(ch!=\u0026#39;\\\u0026#34;\u0026#39;) { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i++]=ch;TOKEN[i]=\u0026#39;\\0\u0026#39;; c=STR; out(c,TOKEN); } else if(ch==\u0026#39;\\\u0026#39;\u0026#39;){ TOKEN[0]=ch; ch=gc(fp,0); i=1; while(ch!=\u0026#39;\\\u0026#39;\u0026#39;) { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i++]=ch;TOKEN[i]=\u0026#39;\\0\u0026#39;; if(strlen(TOKEN)\u0026gt;3)report_error(3); else { c=CHAR; out(c,TOKEN); } } else switch(ch) { case \u0026#39;\u0026lt;\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=LE;out(LE,\u0026#34; \u0026#34;);} else if(ch==\u0026#39;\u0026gt;\u0026#39;) {c=NE;out (NE,\u0026#34; \u0026#34;);} else { myfseek (fp,-1,1); c=LT; out (LT,\u0026#34; \u0026#34;); } break; case \u0026#39;=\u0026#39;: c=EQ; out(EQ, \u0026#34; \u0026#34;); break; case \u0026#39;\u0026gt;\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=GE;out(GE,\u0026#34; \u0026#34;);} else { myfseek(fp,-1,1); c=GT; out(GT,\u0026#34; \u0026#34;); } break; case \u0026#39;:\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=IS;out(IS,\u0026#34; \u0026#34;);} else{ myfseek(fp,-1,1); report_error(4); } break; case \u0026#39;+\u0026#39;: c=PL; out(PL, \u0026#34; \u0026#34;); break; case \u0026#39;-\u0026#39;: c=MI; out(MI, \u0026#34; \u0026#34;); break; case \u0026#39;*\u0026#39;: c=MU; out(MU, \u0026#34; \u0026#34;); break; case \u0026#39;/\u0026#39;: c=DI; out(DI, \u0026#34; \u0026#34;); break; case \u0026#39;\u0026amp;\u0026#39;: c=AND; out(AND, \u0026#34; \u0026#34;); break; case \u0026#39;|\u0026#39;: c=OR; out(OR, \u0026#34; \u0026#34;); break; case \u0026#39;!\u0026#39;: c=NOT; out(NOT, \u0026#34; \u0026#34;); break; case \u0026#39;(\u0026#39;: c= LB ; out( LB ,\u0026#34; \u0026#34;); break; case \u0026#39;)\u0026#39;: c = RB; out(RB,\u0026#34; \u0026#34;); break; case \u0026#39;#\u0026#39;: c = NS; out(NS,\u0026#34; \u0026#34;); break; default: report_error(5); break; } return ; } int scan(FILE* test){//向前读一个单词，帮助避开了空格，回车等符号 char c; if((c=gc(test,1))!=EOF){//试探是否到了文档尾 while(c==\u0026#39; \u0026#39;||c==\u0026#39;\\t\u0026#39;||c==\u0026#39;\\n\u0026#39;){//越过无意义符号 c= gc(test,1); } if(c!=EOF){//防止空格回车结尾 myfseek(test,-1,1); scanner(test); } else {//有特殊符号到了文档尾 cla[idx] = NS; valu[idx] = \u0026#34; \u0026#34;; chra[idx] = NS; } } else {//没有特殊符号也到了文档尾 cla[idx] = NS; valu[idx] = \u0026#34; \u0026#34;; chra[idx] = NS; } return idx++; } //实现语法分析所需 void gen(int r,FILE* fp){//计算值并且输出四元式,给出表达式编号 string g2 = R1[r][1]; int len = g2.length(); int k1,k2; string x1,x2; char sym; if(len==1) {//iTEF T[idx]=T[mea[meat]];//传递中间变量位置 valu[idx] = valu[mea[meat]]; } else if(len==3){//(E)，不分配新的空间 if(chra[mea[meat]]==RB){ T[idx]=tt-1; valu[idx] = valu[mea[meat]]; } else {//算数,分配新的空间 int sy; sy = chra[mea[meat-1]]; k1=T[mea[meat-2]];//为输出四元式的参数1 k2=T[mea[meat]];//输出四元式的参数2 switch(sy){ case PL: sym=\u0026#39;+\u0026#39;; break; case MI: sym=\u0026#39;-\u0026#39;; break; case DI: sym=\u0026#39;/\u0026#39;; break; case MU: sym = \u0026#39;*\u0026#39;; break; } if(k1==-1){ x1=valu[mea[meat-2]]; } else x1 = \u0026#34;T\u0026#34;+ to_string(k1); if(k2==-1){ x2=valu[mea[meat]]; } else x2 = \u0026#34;T\u0026#34;+ to_string(k2); T[idx]=tt++; if(mode==3){ cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt;sym\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;x1\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;x2\u0026lt;\u0026lt;\u0026#34;,T\u0026#34;\u0026lt;\u0026lt;T[idx]\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } fprintf(fp,\u0026#34;(%c,%s,%s,T%d)\\n\u0026#34;,sym,x1.c_str(),x2.c_str(),T[idx]); } } return ; } void slr_init(){ for (int i = 0; i \u0026lt; 200; ++i) { for (int j = 0; j \u0026lt; 200; ++j) { action[i][j] = NULL; } } action[0][LB]=\u0026#34;S4\u0026#34;; action[0][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[1][PL] = \u0026#34;S6\u0026#34;; action[1][MI] = \u0026#34;S7\u0026#34;; action[1][NS] = \u0026#34;Acc\u0026#34;; action[2][RB] = action[2][PL]=action[2][MI]=action[2][NS] = \u0026#34;R3\u0026#34;; action[2][MU] = \u0026#34;S8\u0026#34;; action[2][DI] = \u0026#34;S9\u0026#34;; action[3][RB] =action[3][PL] =action[3][MI] =action[3][MU] =action[3][DI] =action[3][NS] =\u0026#34;R6\u0026#34;; action[4][LB] = \u0026#34;S4\u0026#34;; action[4][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[5][RB] =action[5][PL] =action[5][MI] =action[5][MU] =action[5][DI] =action[5][NS] =\u0026#34;R8\u0026#34;; action[6][LB] = action[7][LB] = action[8][LB] = action[9][LB] = \u0026#34;S4\u0026#34;; action[6][\u0026#39;i\u0026#39;] =action[7][\u0026#39;i\u0026#39;] =action[8][\u0026#39;i\u0026#39;] =action[9][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[10][RB] = \u0026#34;S15\u0026#34;; action[10][PL] =\u0026#34;S6\u0026#34;; action[10][MI] =\u0026#34;S7\u0026#34;; action[11][RB] =action[11][PL] =action[11][MI] =action[11][NS]=\u0026#34;R1\u0026#34;; action[12][RB] =action[12][PL] =action[12][MI] =action[12][NS]=\u0026#34;R2\u0026#34;; action[11][MU] =action[12][MU] =\u0026#34;S8\u0026#34;; action[11][DI] =action[12][DI] =\u0026#34;S9\u0026#34;; action[13][RB] =action[13][PL] =action[13][MI] =action[13][MU] =action[13][DI] =action[13][NS] =\u0026#34;R4\u0026#34;; action[14][RB] =action[14][PL] =action[14][MI] =action[14][MU] =action[14][DI] =action[14][NS] =\u0026#34;R5\u0026#34;; action[15][RB] =action[15][PL] =action[15][MI] =action[15][MU] =action[15][DI] =action[15][NS] =\u0026#34;R7\u0026#34;; //错误分析类型 action[1][LB]=action[2][LB]=action[3][LB]=action[5][LB]=action[10][LB]=action[11][LB]=action[12][LB]=action[13][LB]=action[14][LB]=action[15][LB]=\u0026#34;e3\u0026#34;; action[0][RB]=action[1][RB]=action[4][RB]=action[6][RB]=action[7][RB]=action[8][RB]=action[9][RB]=\u0026#34;e2\u0026#34;; action[0][PL]=action[4][PL]=action[6][PL]=action[7][PL]=action[8][PL]=action[9][PL]=\u0026#34;e1\u0026#34;; action[0][MI]=action[4][MI]=action[6][MI]=action[7][MI]=action[8][MI]=action[9][MI]=\u0026#34;e1\u0026#34;; action[0][MU]=action[4][MU]=action[6][MU]=action[7][MU]=action[8][MU]=action[9][MU]=action[1][MU]=action[10][MU]=\u0026#34;e1\u0026#34;; action[0][DI]=action[4][DI]=action[6][DI]=action[7][DI]=action[8][DI]=action[9][DI]=action[1][DI]=action[10][DI]=\u0026#34;e1\u0026#34;; action[1][\u0026#39;i\u0026#39;]=action[2][\u0026#39;i\u0026#39;]=action[3][\u0026#39;i\u0026#39;]=action[5][\u0026#39;i\u0026#39;]=action[10][\u0026#39;i\u0026#39;]=action[11][\u0026#39;i\u0026#39;]=action[12][\u0026#39;i\u0026#39;]=action[13][\u0026#39;i\u0026#39;]=action[14][\u0026#39;i\u0026#39;]=action[15][\u0026#39;i\u0026#39;]=\u0026#34;e3\u0026#34;; action[0][NS]=action[4][NS]=action[6][NS]=action[7][NS]=action[8][NS]=action[9][NS]=\u0026#34;e1\u0026#34;; action[10][NS]=\u0026#34;e4\u0026#34;; Goto[0][\u0026#39;E\u0026#39;] = 1; Goto[0][\u0026#39;T\u0026#39;] = 2; Goto[0][\u0026#39;F\u0026#39;] = 3; Goto[4][\u0026#39;E\u0026#39;] = 10; Goto[4][\u0026#39;T\u0026#39;] = 2; Goto[4][\u0026#39;F\u0026#39;] = 3; Goto[6][\u0026#39;T\u0026#39;] = 11; Goto[6][\u0026#39;F\u0026#39;] = 3; Goto[7][\u0026#39;T\u0026#39;] = 12; Goto[7][\u0026#39;F\u0026#39;] = 3; Goto[8][\u0026#39;F\u0026#39;] = 13; Goto[9][\u0026#39;F\u0026#39;]= 14; strcpy(follow[\u0026#39;E\u0026#39;],\u0026#34;#)+-\u0026#34;); strcpy(follow[\u0026#39;T\u0026#39;],\u0026#34;#)+_*/\u0026#34;); strcpy(follow[\u0026#39;F\u0026#39;],\u0026#34;#)+_*/\u0026#34;); sta[++stat]=0; syb[++sybt]=NS; } void superSLR1(FILE *fp){ printf(\u0026#34;开始slr分析：\\n\u0026#34;); slr_init(); string str;//存储每一步的表达式 bool x=true;//合法位 int index;//登记位 index = scan(fp); topsta = sta[stat];//状态栈 inpsym = chra[index];//符号栈 str=action[topsta][inpsym];//对应公式 FILE * result = fopen(\u0026#34;/home/zql/CLionProjects/cpex/result.txt\u0026#34;,\u0026#34;w\u0026#34;); fputs(\u0026#34;实验三中间代码生成如下：\\n\u0026#34;,result); while(str!=\u0026#34;Acc\u0026#34;){ if(str[0]==\u0026#39;S\u0026#39;){ int num; if(str.length()==2) num = str[1]-\u0026#39;0\u0026#39;; else if(str.length()==3)num=(str[1]-\u0026#39;0\u0026#39;)*10+str[2]-\u0026#39;0\u0026#39;; mea[++meat] = index;//当前符号入语义栈 if(chra[index]==\u0026#39;i\u0026#39;)T[index]=-1;//如果是数值，保留存储位置 //下一个状态入状态栈，不会出错 sta[++stat] = num; //读入下一个符号，可能会读到错误的非终结符号 index = scan(fp); //入符号栈 syb[++sybt] = chra[index]; if(mode==2){ printf(\u0026#34;移进操作, %d入状态栈, %d入符号栈, 输入串首为%d\\n\u0026#34;,num,syb[sybt],chra[index]); } } else if(str[0]==\u0026#39;R\u0026#39;){ int num = str[1]-\u0026#39;0\u0026#39;;//表达式编号 string r = R1[num][1]; if(mode==2){ cout\u0026lt;\u0026lt;\u0026#34;归约操作, 根据R\u0026#34;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;\u0026#34;, 表达式为\u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; } int len = r.length(); stat-=len; sybt-=len; gen(num,result);//计算并且生成四元式 meat-=len; topsta = sta[stat]; syb[++sybt]=R1[num][0][0];//规约 if(mode==2){ printf(\u0026#34; 规约为的非终结符号%c，入符号栈,\u0026#34;,syb[sybt]); } sta[++stat]=Goto[topsta][syb[sybt]]; mea[++meat] = idx; if(mode==2){ printf(\u0026#34; 规约后%d入状态栈\\n\u0026#34;,sta[stat] ); } idx++; } else if (str[0]==\u0026#39;e\u0026#39;){ //说明按照str中的位置找到的错误，则当前符号栈顶的符号是错误的 int num= str[1]-\u0026#39;0\u0026#39;; report_error(num+10); if(num==4)break; x=false; // 跳过当前的终结符号，将当前状态和下一个终结符号组合，寻找下一个表达式 index=scan(fp); syb[sybt] = chra[index]; } //查表 topsta = sta[stat]; inpsym = chra[index]; str=action[topsta][inpsym]; } if(x)printf(\u0026#34;合法!\\n\u0026#34;); return ; } //主函数 int main() { printf(\u0026#34;请选择输出结果类型(查看实验一结果请输入1，类推):\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;mode); FILE* test = fopen(\u0026#34;/home/zql/CLionProjects/cpex/text\u0026#34;,\u0026#34;r\u0026#34;); superSLR1(test); fclose(test); return 0; } \\ ","permalink":"https://zqlqy.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/","summary":"#include \u0026lt;cstring\u0026gt; #include \u0026lt;valarray\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //宏定义声明 //实现词法分析所需 //宏定义各种符号类型 #define DIGIT 1 #define POINT 2 #define OTHER 3 #define POWER 4 #define PLUS 5 #define MINUS 6 # define ID 7 # define INT 8 # define REAL 9 # define LT 10 # define LE 11 # define EQ 12 # define NE 13 # define GT 14 # define GE 15 # define IS 16 # define PL 17 # define MI 18 # define MU 19 # define DI 20 # define AND 21 # define OR 22 # define NOT 23 # define STR 24 # define CHAR 25 # define OCT 26 # define HEX 27 # define LB 28 # define RB 29 # define NS 30 # define UCON 97 # define ClassOther 200 # define EndState -1 #define MAX_KEY_NUMBER 20 /*关键字的数量*/ #define KEY_WORD_END \u0026#34;#\u0026#34; /*关键字结束标记*/ //输出设置（为区分实验结果） int mode = 0; // 变量定义 // 实现词法分析所需 const int N=10000;// 够用 char *KeyWordTable[MAX_KEY_NUMBER]={\u0026#34;begin\u0026#34;,\u0026#34;end\u0026#34;, \u0026#34;const\u0026#34;,\u0026#34;var\u0026#34;,\u0026#34;if\u0026#34;, \u0026#34;else\u0026#34;,KEY_WORD_END};//关键词表 //实数分析 int w,n,p,e,d;//实数分析所需 int Class;//实数分析类别 int ICON;//实数分析 float FCON;//实数分析的值 static int CurrentState;//实数分析当前状态 //扫描用 int adx=1,ady=1;//当前读入的位置 char ch; //当前读入的字符，必须要设定这个全局变量，在回退之前检查一下是否为EOF,在scanner中为EOF不回退 char TOKEN[20];//每个读入单词 //实现语法分析所需 int sta[10010];//状态栈 int syb[10010];//符号栈 int mea[1010];//语义栈 int stat=0,sybt=0; int meat=0;//以上三栈的栈顶 int topsta;//状态栈顶,在action表中用 int inpsym;//输入符号串顶，在action表中用 //语法本身 char* action[200][200];//action表 int Goto[200][200];//goto表 string R1[100][2]= {{\u0026#34;S\u0026#34;,\u0026#34;E\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E+T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E-T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;T\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;}, {\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;F\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;(E)\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;i\u0026#34;}};//语法 char follow[300][50]; //实现语义分析所需 int idx=0;//每个键值对的索引（key,value） string valu[N];//每个单词的值 int cla[N];//每个单词的类型 int chra[N];//每个单词在语法中扮演的角色 int T[N]={}; int tt=1;//临时变量编号 //函数定义 //报错函数 void report_error(int errcla){ int k=0; char* str; switch (errcla){ case 1: str = \u0026#34;十六进制数表示错误\u0026#34;; break; case 2: str = \u0026#34;八进制数表示错误\u0026#34;; break; case 3: str = \u0026#34;字符型常量定义错误\u0026#34;; break; case 4: str = \u0026#34;非法运算符\u0026#34;; break; case 5: str = \u0026#34;未定义符号\u0026#34;; break; case 6: str=\u0026#34;语法错误\u0026#34;; k=1; break; case 7: str = \u0026#34;未找到表达式\u0026#34;; k=2; break; case 8: str = \u0026#34;不是算符优先文法\u0026#34;; k=2; break; case 11: str=\u0026#34;缺少运算分量\u0026#34;; k=2; break; case 12: str=\u0026#34;不匹配的右括号\u0026#34;; k=2; break; case 13: str=\u0026#34;缺少运算符\u0026#34;; k=2; break; case 14: str=\u0026#34;缺少右括号\u0026#34;; k=2; break; } if(!","title":"编译原理实验"}]