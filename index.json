[{"content":"åˆ°ç°åœ¨ä¸ºæ­¢ï¼Œå…±æœ‰ä¸‰ç§é‡è¦çš„ç”Ÿæˆæ¨¡å‹ï¼ŒGAN,VAEå’ŒFlow-basedæ¨¡å‹ã€‚ä»–ä»¬åœ¨ç”Ÿæˆé«˜è´¨é‡æ ·æœ¬çš„ä»»åŠ¡ä¸­è¡¨ç°å¾ˆå¥½ï¼Œä½†ä¹Ÿæœ‰å„è‡ªçš„ç¼ºé™·ã€‚GANå› ä¸ºå…¶å¯¹æŠ—è®­ç»ƒçš„æœ¬è´¨ï¼Œåœ¨è®­ç»ƒä¸­æ½œåœ¨çš„ä¸ç¡®å®šæ€§ï¼Œåœ¨ç”Ÿæˆæ ·æœ¬æ—¶ç¼ºä¹å¤šæ ·åŒ–ï¼›VAEä¾èµ–æ›¿ä»£æŸå¤±(surrogate loss)ï¼›Flow-basedæ¨¡å‹å¿…é¡»ä½¿ç”¨ç‰¹å®šçš„ç»“æ„æ¥æ„å»ºå¯é€†çš„å˜æ¢ã€‚\nDiffusionæ¥è‡ªäºéå¹³è¡¡çƒ­åŠ›å­¦çš„å¯å‘ã€‚ä»–ä»¬å®šä¹‰äº†åœ¨æ‰©æ•£è¿‡ç¨‹ä¸­ç¼“æ…¢åœ°å‘æ•°æ®ä¸­åŠ å…¥éšæœºå™ªå£°çš„é©¬å°”ç§‘å¤«é“¾ï¼Œä¹‹åå°è¯•å»å­¦ä¹ é€†å‘æ‰©æ•£è¿‡ç¨‹ï¼Œæ¥ä»å™ªå£°ä¸­å¡‘é€ æˆ‘ä»¬æƒ³è¦çš„æ ·æœ¬ã€‚ä¸VAEæˆ–è€…flow-basedæ¨¡å‹ä¸åŒï¼Œæ‰©æ•£æ¨¡å‹å…·æœ‰å›ºå®šçš„æ­¥éª¤ï¼Œå¹¶ä¸”å…¶ä¸­çš„æ½œå˜é‡å¯ä»¥æ‹¥æœ‰é«˜ç»´åº¦(ä¸åŸå§‹æ•°æ®ç»´åº¦ç›¸åŒ)ã€‚\nä»€ä¹ˆæ˜¯æ‰©æ•£æ¨¡å‹ï¼Ÿ ä¸€äº›åŸºäºæ‰©æ•£æ€æƒ³çš„æ¨¡å‹paperå¦‚ä¸‹ï¼š\ndiffusion probabilistic models (Sohl-Dickstein et al., 2015)\nnoise-conditioned score network ( NCSN ; Yang \u0026amp; Ermon, 2019)\nand denoising diffusion probabilistic models ( DDPM ; Ho et al. 2020)\nå‰å‘æ‰©æ•£è¿‡ç¨‹ å¯¹äºç»™å®šä»çœŸå®åˆ†å¸ƒä¸­é‡‡æ ·çš„ $ğ‘¥_0âˆ¼ğ‘(ğ‘¥)$\n","permalink":"https://zqlqy.github.io/posts/diffusion%E7%AE%80%E4%BB%8B/","summary":"åˆ°ç°åœ¨ä¸ºæ­¢ï¼Œå…±æœ‰ä¸‰ç§é‡è¦çš„ç”Ÿæˆæ¨¡å‹ï¼ŒGAN,VAEå’ŒFlow-basedæ¨¡å‹ã€‚ä»–ä»¬åœ¨ç”Ÿæˆé«˜è´¨é‡æ ·æœ¬çš„ä»»åŠ¡ä¸­è¡¨ç°å¾ˆå¥½ï¼Œä½†ä¹Ÿæœ‰å„è‡ªçš„ç¼ºé™·ã€‚GANå› ä¸ºå…¶å¯¹æŠ—è®­ç»ƒçš„æœ¬è´¨ï¼Œåœ¨è®­ç»ƒä¸­æ½œåœ¨çš„ä¸ç¡®å®šæ€§ï¼Œåœ¨ç”Ÿæˆæ ·æœ¬æ—¶ç¼ºä¹å¤šæ ·åŒ–ï¼›VAEä¾èµ–æ›¿ä»£æŸå¤±(surrogate loss)ï¼›Flow-basedæ¨¡å‹å¿…é¡»ä½¿ç”¨ç‰¹å®šçš„ç»“æ„æ¥æ„å»ºå¯é€†çš„å˜æ¢ã€‚\nDiffusionæ¥è‡ªäºéå¹³è¡¡çƒ­åŠ›å­¦çš„å¯å‘ã€‚ä»–ä»¬å®šä¹‰äº†åœ¨æ‰©æ•£è¿‡ç¨‹ä¸­ç¼“æ…¢åœ°å‘æ•°æ®ä¸­åŠ å…¥éšæœºå™ªå£°çš„é©¬å°”ç§‘å¤«é“¾ï¼Œä¹‹åå°è¯•å»å­¦ä¹ é€†å‘æ‰©æ•£è¿‡ç¨‹ï¼Œæ¥ä»å™ªå£°ä¸­å¡‘é€ æˆ‘ä»¬æƒ³è¦çš„æ ·æœ¬ã€‚ä¸VAEæˆ–è€…flow-basedæ¨¡å‹ä¸åŒï¼Œæ‰©æ•£æ¨¡å‹å…·æœ‰å›ºå®šçš„æ­¥éª¤ï¼Œå¹¶ä¸”å…¶ä¸­çš„æ½œå˜é‡å¯ä»¥æ‹¥æœ‰é«˜ç»´åº¦(ä¸åŸå§‹æ•°æ®ç»´åº¦ç›¸åŒ)ã€‚\nä»€ä¹ˆæ˜¯æ‰©æ•£æ¨¡å‹ï¼Ÿ ä¸€äº›åŸºäºæ‰©æ•£æ€æƒ³çš„æ¨¡å‹paperå¦‚ä¸‹ï¼š\ndiffusion probabilistic models (Sohl-Dickstein et al., 2015)\nnoise-conditioned score network ( NCSN ; Yang \u0026amp; Ermon, 2019)\nand denoising diffusion probabilistic models ( DDPM ; Ho et al. 2020)\nå‰å‘æ‰©æ•£è¿‡ç¨‹ å¯¹äºç»™å®šä»çœŸå®åˆ†å¸ƒä¸­é‡‡æ ·çš„ $ğ‘¥_0âˆ¼ğ‘(ğ‘¥)$","title":"Diffusionç®€ä»‹"},{"content":" #include \u0026lt;cstring\u0026gt; #include \u0026lt;valarray\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //å®å®šä¹‰å£°æ˜ //å®ç°è¯æ³•åˆ†ææ‰€éœ€ //å®å®šä¹‰å„ç§ç¬¦å·ç±»å‹ #define DIGIT 1 #define POINT 2 #define OTHER 3 #define POWER 4 #define PLUS 5 #define MINUS 6 # define ID 7 # define INT 8 # define REAL 9 # define LT 10 # define LE 11 # define EQ 12 # define NE 13 # define GT 14 # define GE 15 # define IS 16 # define PL 17 # define MI 18 # define MU 19 # define DI 20 # define AND 21 # define OR 22 # define NOT 23 # define STR 24 # define CHAR 25 # define OCT 26 # define HEX 27 # define LB 28 # define RB 29 # define NS 30 # define UCON 97 # define ClassOther 200 # define EndState -1 #define MAX_KEY_NUMBER 20 /*å…³é”®å­—çš„æ•°é‡*/ #define KEY_WORD_END \u0026#34;#\u0026#34; /*å…³é”®å­—ç»“æŸæ ‡è®°*/ //è¾“å‡ºè®¾ç½®ï¼ˆä¸ºåŒºåˆ†å®éªŒç»“æœï¼‰ int mode = 0; // å˜é‡å®šä¹‰ // å®ç°è¯æ³•åˆ†ææ‰€éœ€ const int N=10000;// å¤Ÿç”¨ char *KeyWordTable[MAX_KEY_NUMBER]={\u0026#34;begin\u0026#34;,\u0026#34;end\u0026#34;, \u0026#34;const\u0026#34;,\u0026#34;var\u0026#34;,\u0026#34;if\u0026#34;, \u0026#34;else\u0026#34;,KEY_WORD_END};//å…³é”®è¯è¡¨ //å®æ•°åˆ†æ int w,n,p,e,d;//å®æ•°åˆ†ææ‰€éœ€ int Class;//å®æ•°åˆ†æç±»åˆ« int ICON;//å®æ•°åˆ†æ float FCON;//å®æ•°åˆ†æçš„å€¼ static int CurrentState;//å®æ•°åˆ†æå½“å‰çŠ¶æ€ //æ‰«æç”¨ int adx=1,ady=1;//å½“å‰è¯»å…¥çš„ä½ç½® char ch; //å½“å‰è¯»å…¥çš„å­—ç¬¦ï¼Œå¿…é¡»è¦è®¾å®šè¿™ä¸ªå…¨å±€å˜é‡ï¼Œåœ¨å›é€€ä¹‹å‰æ£€æŸ¥ä¸€ä¸‹æ˜¯å¦ä¸ºEOF,åœ¨scannerä¸­ä¸ºEOFä¸å›é€€ char TOKEN[20];//æ¯ä¸ªè¯»å…¥å•è¯ //å®ç°è¯­æ³•åˆ†ææ‰€éœ€ int sta[10010];//çŠ¶æ€æ ˆ int syb[10010];//ç¬¦å·æ ˆ int mea[1010];//è¯­ä¹‰æ ˆ int stat=0,sybt=0; int meat=0;//ä»¥ä¸Šä¸‰æ ˆçš„æ ˆé¡¶ int topsta;//çŠ¶æ€æ ˆé¡¶,åœ¨actionè¡¨ä¸­ç”¨ int inpsym;//è¾“å…¥ç¬¦å·ä¸²é¡¶ï¼Œåœ¨actionè¡¨ä¸­ç”¨ //è¯­æ³•æœ¬èº« char* action[200][200];//actionè¡¨ int Goto[200][200];//gotoè¡¨ string R1[100][2]= {{\u0026#34;S\u0026#34;,\u0026#34;E\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E+T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E-T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;T\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;}, {\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;F\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;(E)\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;i\u0026#34;}};//è¯­æ³• char follow[300][50]; //å®ç°è¯­ä¹‰åˆ†ææ‰€éœ€ int idx=0;//æ¯ä¸ªé”®å€¼å¯¹çš„ç´¢å¼•ï¼ˆkey,valueï¼‰ string valu[N];//æ¯ä¸ªå•è¯çš„å€¼ int cla[N];//æ¯ä¸ªå•è¯çš„ç±»å‹ int chra[N];//æ¯ä¸ªå•è¯åœ¨è¯­æ³•ä¸­æ‰®æ¼”çš„è§’è‰² int T[N]={}; int tt=1;//ä¸´æ—¶å˜é‡ç¼–å· //å‡½æ•°å®šä¹‰ //æŠ¥é”™å‡½æ•° void report_error(int errcla){ int k=0; char* str; switch (errcla){ case 1: str = \u0026#34;åå…­è¿›åˆ¶æ•°è¡¨ç¤ºé”™è¯¯\u0026#34;; break; case 2: str = \u0026#34;å…«è¿›åˆ¶æ•°è¡¨ç¤ºé”™è¯¯\u0026#34;; break; case 3: str = \u0026#34;å­—ç¬¦å‹å¸¸é‡å®šä¹‰é”™è¯¯\u0026#34;; break; case 4: str = \u0026#34;éæ³•è¿ç®—ç¬¦\u0026#34;; break; case 5: str = \u0026#34;æœªå®šä¹‰ç¬¦å·\u0026#34;; break; case 6: str=\u0026#34;è¯­æ³•é”™è¯¯\u0026#34;; k=1; break; case 7: str = \u0026#34;æœªæ‰¾åˆ°è¡¨è¾¾å¼\u0026#34;; k=2; break; case 8: str = \u0026#34;ä¸æ˜¯ç®—ç¬¦ä¼˜å…ˆæ–‡æ³•\u0026#34;; k=2; break; case 11: str=\u0026#34;ç¼ºå°‘è¿ç®—åˆ†é‡\u0026#34;; k=2; break; case 12: str=\u0026#34;ä¸åŒ¹é…çš„å³æ‹¬å·\u0026#34;; k=2; break; case 13: str=\u0026#34;ç¼ºå°‘è¿ç®—ç¬¦\u0026#34;; k=2; break; case 14: str=\u0026#34;ç¼ºå°‘å³æ‹¬å·\u0026#34;; k=2; break; } if(!k){printf(\u0026#34;è¯æ³•åˆ†æå‘ç”Ÿé”™è¯¯!é”™è¯¯ä½ç½®ï¼šç¬¬%dè¡Œï¼Œç¬¬%dä¸ªå­—ç¬¦ï¼›é”™è¯¯ç±»å‹ï¼š%s\\n\u0026#34;,adx,ady-1,str);} else if (k==2) { printf(\u0026#34;è¯­æ³•åˆ†æå‘ç”Ÿé”™è¯¯ï¼é”™è¯¯ç±»å‹ï¼š%s, é”™è¯¯ä½ç½®ï¼šç¬¬%dè¡Œï¼Œç¬¬%dä¸ªå­—ç¬¦\\n\u0026#34;, str, adx,ady); } return; } //å®ç°è¯­æ³•åˆ†ææ‰€éœ€ //è‡ªå®šä¹‰è¯»å…¥å‡½æ•° char gc(FILE* fp,int index){//indexæ˜¯æ¢è¡Œå…è®¸ä½ char ch =fgetc(fp); //printf(\u0026#34;%c \u0026#34;,ch); if(ch==\u0026#39;\\n\u0026#39;\u0026amp;\u0026amp;index){ adx++; ady=1; // // printf(\u0026#34;æ¢è¡Œ,%d\u0026#34;,adx); } else ady++; //printf(\u0026#34;(%d,%d)\\n\u0026#34;,adx,ady); return ch; } void myfseek(FILE* fp ,int off ,int whence ){ if(ch!=EOF){ fseek(fp,off,whence); ady+=off; } } //æŸ¥æ‰¾ç±»åˆ«å¹¶è¾“å‡ºå‡½æ•° int lookup (char *token) { int n=0; while (strcmp(KeyWordTable[n], KEY_WORD_END)) /*strcmpæ¯”è¾ƒä¸¤ä¸²æ˜¯å¦ç›¸åŒï¼Œè‹¥ç›¸åŒè¿”å›0*/ { if (!strcmp(KeyWordTable[n], token)) /*æ¯”è¾ƒtokenæ‰€æŒ‡å‘çš„å…³é”®å­—å’Œä¿ç•™å­—è¡¨ä¸­å“ªä¸ªå…³é”®å­—ç›¸ç¬¦*/ { return n+1; /*æ ¹æ®å•è¯åˆ†ç±»ç è¡¨Iï¼Œè®¾ç½®æ­£ç¡®çš„å…³é”®å­—ç±»åˆ«ç ï¼Œå¹¶è¿”å›æ­¤ç±»åˆ«ç çš„å€¼*/ } n++; } return 7; /*å•è¯ä¸æ˜¯å…³é”®å­—ï¼Œè€Œæ˜¯æ ‡è¯†ç¬¦*/ } void out(int c, string val) { char* str; switch (c) { case 1: str = \u0026#34;BEGIN\u0026#34;; break; case 2: str = \u0026#34;END\u0026#34;; break; case 3: str = \u0026#34;CONST\u0026#34;; break; case 4: str = \u0026#34;VAR\u0026#34;; break; case 5: str = \u0026#34;IF\u0026#34;; break; case 6: str = \u0026#34;ELSE\u0026#34;; break; case 7: str = \u0026#34;ID\u0026#34;; break; case 8: str=\u0026#34;INT\u0026#34;; break; case 9: str = \u0026#34;REAL\u0026#34;; break; case 10: str = \u0026#34;LT\u0026#34;; break; case 11: str = \u0026#34;LE\u0026#34;; break; case 12: str = \u0026#34;EQ\u0026#34;; break; case 13: str = \u0026#34;NE\u0026#34;; break; case 14: str = \u0026#34;GT\u0026#34;; break; case 15: str=\u0026#34;GE\u0026#34;; break; case 16: str = \u0026#34;IS\u0026#34;; break; case 17: str = \u0026#34;PL\u0026#34;; break; case 18: str = \u0026#34;MI\u0026#34;; break; case 19: str = \u0026#34;MU\u0026#34;; break; case 20: str = \u0026#34;DI\u0026#34;; break; case 21: str = \u0026#34;AND\u0026#34;; break; case 22: str = \u0026#34;OR\u0026#34;; break; case 23: str = \u0026#34;NOT\u0026#34;; break; case 24: str = \u0026#34;STR\u0026#34;; break; case 25: str = \u0026#34;CHAR\u0026#34;; break; case 26: str = \u0026#34;OCT\u0026#34;; break; case 27: str = \u0026#34;HEX\u0026#34;; break; case 28: str = \u0026#34;LB\u0026#34;; break; case 29: str = \u0026#34;RB\u0026#34;; break; case 30: str = \u0026#34;NS\u0026#34;; break; } cla[idx] = c; valu[idx] = val; if(c!=LB\u0026amp;\u0026amp;c!=RB\u0026amp;\u0026amp;c!=PL\u0026amp;\u0026amp;c!=MI\u0026amp;\u0026amp;c!=MU\u0026amp;\u0026amp;c!=DI\u0026amp;\u0026amp;c!=NS){//ä¸æ˜¯è¿ç®—ç¬¦å· chra[idx] = \u0026#39;i\u0026#39;; } else { chra[idx] = c; } if(mode==1){ cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;val\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } } //å®éªŒç»™çš„æ²¡å•¥ç”¨å‡½æ•° int HandleOtherWord (void) { return ClassOther; } int HandleError (void){ printf(\u0026#34;Error!\\n\u0026#34;); return 0; } int GetChar (FILE* fp) { int c; c = gc(fp,0); if (c != EOF) { if (isdigit(c)) { d = c - \u0026#39;0\u0026#39;; return DIGIT; } if (c == \u0026#39;.\u0026#39;) return POINT; if (c == \u0026#39;E\u0026#39; || c == \u0026#39;e\u0026#39;) return POWER; if (c == \u0026#39;+\u0026#39;) return PLUS; if (c == \u0026#39;-\u0026#39;) return MINUS; } return OTHER;//è¿”å›å½“å‰å­—ç¬¦çš„ç±» } int EXCUTE (int state, int symbol) { switch (state) { case 0:switch (symbol) { case DIGIT: n=0;p=0;e=1;w=d;CurrentState=1;Class=UCON;break; case POINT: w=0;n=0;p=0;e=1;CurrentState=3;Class=UCON;break; default: HandleOtherWord( );Class=ClassOther; CurrentState=EndState; } break; case 1:switch (symbol) { case DIGIT: w=w*10+d;break; //CurrentState=1 case POINT: CurrentState=2;break; case POWER: CurrentState=4;break; default: ICON=w;CurrentState=EndState; } break; case 2:switch (symbol) { case DIGIT: n++;w=w*10+d;break; case POWER: CurrentState=4;break; default: FCON=w*pow(10,e*p-n);CurrentState=EndState; } break; case 3:switch (symbol) { case DIGIT: n++;w=w*10+d;CurrentState=2;break; default: HandleError( );CurrentState=EndState; } break; case 4:switch (symbol) { case DIGIT: p=p*10+d;CurrentState=6;break; case MINUS: e=-1;CurrentState=5;break; case PLUS: CurrentState=5;break; default: HandleError( );CurrentState=EndState; } break; case 5:switch (symbol) { case DIGIT: p=p*10+d;CurrentState=6;break; default: HandleError( );CurrentState=EndState; } break; case 6:switch (symbol) { case DIGIT:p=p*10+d;break; default: FCON=w*pow(10,e*p-n);CurrentState=EndState; } break; } return CurrentState; } int LEX (FILE* fp) { int ch; CurrentState=0; while (CurrentState!=EndState) { ch=GetChar(fp); EXCUTE (CurrentState,ch); } myfseek(fp,-1,1); return Class; } //æ‹“å±•å®éªŒåˆ†æåå…­è¿›åˆ¶æ•°æ‰€éœ€ int ISABCDEF(char x){ int n=0; char al[20]={\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;#\u0026#39;}; while (al[n]!=\u0026#39;#\u0026#39;) /*strcmpæ¯”è¾ƒä¸¤ä¸²æ˜¯å¦ç›¸åŒï¼Œè‹¥ç›¸åŒè¿”å›0*/ { if (al[n]==x) { return 1; } n++; } return 0; /*å•è¯ä¸æ˜¯å…³é”®å­—ï¼Œè€Œæ˜¯æ ‡è¯†ç¬¦*/ } //æ‰«æå™¨ä¸å•ä¸ªæ‰«æ void scanner(FILE *fp) { int i, c; ch=gc(fp,0); if (isalpha (ch)) { TOKEN[0]=ch; ch=gc(fp,0); i=1;//åˆå§‹åŒ– while (isalnum (ch))//æ˜¯å¦ä¸ºå­—æ¯æˆ–è€…æ•°å­— { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i]= \u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); c=lookup(TOKEN);//æŸ¥æ‰¾æºç¨‹åºï¼Œ if(c==ID)out(c,TOKEN); else out(c,\u0026#34; \u0026#34;); } else if(isdigit(ch)) { //å°†æ•°å­—éƒ¨åˆ†è¯»å…¥tokenï¼Œ TOKEN[0]=ch;i=1; if(ch==\u0026#39;0\u0026#39;){ ch=gc(fp,0); if(ch==\u0026#39;x\u0026#39;){ TOKEN[i]=ch; i++; ch=gc(fp,0); bool is=1; while(isalnum(ch)) { if(isalpha(ch)\u0026amp;\u0026amp;!ISABCDEF(ch)){ report_error(1); is=0; break; } TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i]=\u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); if(is){ c=HEX; out(c,TOKEN); } } else if(isdigit(ch)){ bool is=1; while(isdigit(ch)) { if(ch\u0026gt;=\u0026#39;8\u0026#39;){ report_error(2); is=0; break; } else { TOKEN[i]=ch; i++; ch=gc(fp,0); } } myfseek(fp,-1,1); TOKEN[i]= \u0026#39;\\0\u0026#39;; if(is){ c=OCT; out(c,TOKEN); } } else { TOKEN[i]=\u0026#39;\\0\u0026#39;; out(INT,TOKEN); } } else { ch=gc(fp,0); while(isdigit(ch)) { TOKEN[i]=ch; i++; ch=gc(fp,0); } if(ch==\u0026#39;.\u0026#39;||ch==\u0026#39;E\u0026#39;||ch==\u0026#39;e\u0026#39;){ myfseek(fp,-i-1,1); LEX(fp); c=REAL; if(mode==1){ cout\u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; \u0026#34;REAL,\u0026#34; \u0026lt;\u0026lt;FCON\u0026lt;\u0026lt; \u0026#34;)\u0026#34;\u0026lt;\u0026lt; endl; } //cout\u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; \u0026#34;REAL,\u0026#34; \u0026lt;\u0026lt;FCON\u0026lt;\u0026lt; \u0026#34;)\u0026#34;\u0026lt;\u0026lt; endl; cla[idx] = REAL; valu[idx] = to_string(FCON); chra[idx] = \u0026#39;i\u0026#39;; //printf(\u0026#34;(REAL,%.12lf %e %g )\\n\u0026#34;,FCON);//æ·»åŠ èŒƒå›´è¯†åˆ« } else{ TOKEN[i]= \u0026#39;\\0\u0026#39;; myfseek(fp,-1,1); c=INT; out(c,TOKEN); } } } else if(ch==\u0026#39;\\\u0026#34;\u0026#39;){ TOKEN[0]=ch; ch=gc(fp,0); i=1; while(ch!=\u0026#39;\\\u0026#34;\u0026#39;) { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i++]=ch;TOKEN[i]=\u0026#39;\\0\u0026#39;; c=STR; out(c,TOKEN); } else if(ch==\u0026#39;\\\u0026#39;\u0026#39;){ TOKEN[0]=ch; ch=gc(fp,0); i=1; while(ch!=\u0026#39;\\\u0026#39;\u0026#39;) { TOKEN[i]=ch; i++; ch=gc(fp,0); } TOKEN[i++]=ch;TOKEN[i]=\u0026#39;\\0\u0026#39;; if(strlen(TOKEN)\u0026gt;3)report_error(3); else { c=CHAR; out(c,TOKEN); } } else switch(ch) { case \u0026#39;\u0026lt;\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=LE;out(LE,\u0026#34; \u0026#34;);} else if(ch==\u0026#39;\u0026gt;\u0026#39;) {c=NE;out (NE,\u0026#34; \u0026#34;);} else { myfseek (fp,-1,1); c=LT; out (LT,\u0026#34; \u0026#34;); } break; case \u0026#39;=\u0026#39;: c=EQ; out(EQ, \u0026#34; \u0026#34;); break; case \u0026#39;\u0026gt;\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=GE;out(GE,\u0026#34; \u0026#34;);} else { myfseek(fp,-1,1); c=GT; out(GT,\u0026#34; \u0026#34;); } break; case \u0026#39;:\u0026#39;: ch=gc(fp,0); if(ch==\u0026#39;=\u0026#39;){c=IS;out(IS,\u0026#34; \u0026#34;);} else{ myfseek(fp,-1,1); report_error(4); } break; case \u0026#39;+\u0026#39;: c=PL; out(PL, \u0026#34; \u0026#34;); break; case \u0026#39;-\u0026#39;: c=MI; out(MI, \u0026#34; \u0026#34;); break; case \u0026#39;*\u0026#39;: c=MU; out(MU, \u0026#34; \u0026#34;); break; case \u0026#39;/\u0026#39;: c=DI; out(DI, \u0026#34; \u0026#34;); break; case \u0026#39;\u0026amp;\u0026#39;: c=AND; out(AND, \u0026#34; \u0026#34;); break; case \u0026#39;|\u0026#39;: c=OR; out(OR, \u0026#34; \u0026#34;); break; case \u0026#39;!\u0026#39;: c=NOT; out(NOT, \u0026#34; \u0026#34;); break; case \u0026#39;(\u0026#39;: c= LB ; out( LB ,\u0026#34; \u0026#34;); break; case \u0026#39;)\u0026#39;: c = RB; out(RB,\u0026#34; \u0026#34;); break; case \u0026#39;#\u0026#39;: c = NS; out(NS,\u0026#34; \u0026#34;); break; default: report_error(5); break; } return ; } int scan(FILE* test){//å‘å‰è¯»ä¸€ä¸ªå•è¯ï¼Œå¸®åŠ©é¿å¼€äº†ç©ºæ ¼ï¼Œå›è½¦ç­‰ç¬¦å· char c; if((c=gc(test,1))!=EOF){//è¯•æ¢æ˜¯å¦åˆ°äº†æ–‡æ¡£å°¾ while(c==\u0026#39; \u0026#39;||c==\u0026#39;\\t\u0026#39;||c==\u0026#39;\\n\u0026#39;){//è¶Šè¿‡æ— æ„ä¹‰ç¬¦å· c= gc(test,1); } if(c!=EOF){//é˜²æ­¢ç©ºæ ¼å›è½¦ç»“å°¾ myfseek(test,-1,1); scanner(test); } else {//æœ‰ç‰¹æ®Šç¬¦å·åˆ°äº†æ–‡æ¡£å°¾ cla[idx] = NS; valu[idx] = \u0026#34; \u0026#34;; chra[idx] = NS; } } else {//æ²¡æœ‰ç‰¹æ®Šç¬¦å·ä¹Ÿåˆ°äº†æ–‡æ¡£å°¾ cla[idx] = NS; valu[idx] = \u0026#34; \u0026#34;; chra[idx] = NS; } return idx++; } //å®ç°è¯­æ³•åˆ†ææ‰€éœ€ void gen(int r,FILE* fp){//è®¡ç®—å€¼å¹¶ä¸”è¾“å‡ºå››å…ƒå¼,ç»™å‡ºè¡¨è¾¾å¼ç¼–å· string g2 = R1[r][1]; int len = g2.length(); int k1,k2; string x1,x2; char sym; if(len==1) {//iTEF T[idx]=T[mea[meat]];//ä¼ é€’ä¸­é—´å˜é‡ä½ç½® valu[idx] = valu[mea[meat]]; } else if(len==3){//(E)ï¼Œä¸åˆ†é…æ–°çš„ç©ºé—´ if(chra[mea[meat]]==RB){ T[idx]=tt-1; valu[idx] = valu[mea[meat]]; } else {//ç®—æ•°,åˆ†é…æ–°çš„ç©ºé—´ int sy; sy = chra[mea[meat-1]]; k1=T[mea[meat-2]];//ä¸ºè¾“å‡ºå››å…ƒå¼çš„å‚æ•°1 k2=T[mea[meat]];//è¾“å‡ºå››å…ƒå¼çš„å‚æ•°2 switch(sy){ case PL: sym=\u0026#39;+\u0026#39;; break; case MI: sym=\u0026#39;-\u0026#39;; break; case DI: sym=\u0026#39;/\u0026#39;; break; case MU: sym = \u0026#39;*\u0026#39;; break; } if(k1==-1){ x1=valu[mea[meat-2]]; } else x1 = \u0026#34;T\u0026#34;+ to_string(k1); if(k2==-1){ x2=valu[mea[meat]]; } else x2 = \u0026#34;T\u0026#34;+ to_string(k2); T[idx]=tt++; if(mode==3){ cout\u0026lt;\u0026lt;\u0026#34;(\u0026#34;\u0026lt;\u0026lt;sym\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;x1\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;x2\u0026lt;\u0026lt;\u0026#34;,T\u0026#34;\u0026lt;\u0026lt;T[idx]\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } fprintf(fp,\u0026#34;(%c,%s,%s,T%d)\\n\u0026#34;,sym,x1.c_str(),x2.c_str(),T[idx]); } } return ; } void slr_init(){ for (int i = 0; i \u0026lt; 200; ++i) { for (int j = 0; j \u0026lt; 200; ++j) { action[i][j] = NULL; } } action[0][LB]=\u0026#34;S4\u0026#34;; action[0][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[1][PL] = \u0026#34;S6\u0026#34;; action[1][MI] = \u0026#34;S7\u0026#34;; action[1][NS] = \u0026#34;Acc\u0026#34;; action[2][RB] = action[2][PL]=action[2][MI]=action[2][NS] = \u0026#34;R3\u0026#34;; action[2][MU] = \u0026#34;S8\u0026#34;; action[2][DI] = \u0026#34;S9\u0026#34;; action[3][RB] =action[3][PL] =action[3][MI] =action[3][MU] =action[3][DI] =action[3][NS] =\u0026#34;R6\u0026#34;; action[4][LB] = \u0026#34;S4\u0026#34;; action[4][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[5][RB] =action[5][PL] =action[5][MI] =action[5][MU] =action[5][DI] =action[5][NS] =\u0026#34;R8\u0026#34;; action[6][LB] = action[7][LB] = action[8][LB] = action[9][LB] = \u0026#34;S4\u0026#34;; action[6][\u0026#39;i\u0026#39;] =action[7][\u0026#39;i\u0026#39;] =action[8][\u0026#39;i\u0026#39;] =action[9][\u0026#39;i\u0026#39;] = \u0026#34;S5\u0026#34;; action[10][RB] = \u0026#34;S15\u0026#34;; action[10][PL] =\u0026#34;S6\u0026#34;; action[10][MI] =\u0026#34;S7\u0026#34;; action[11][RB] =action[11][PL] =action[11][MI] =action[11][NS]=\u0026#34;R1\u0026#34;; action[12][RB] =action[12][PL] =action[12][MI] =action[12][NS]=\u0026#34;R2\u0026#34;; action[11][MU] =action[12][MU] =\u0026#34;S8\u0026#34;; action[11][DI] =action[12][DI] =\u0026#34;S9\u0026#34;; action[13][RB] =action[13][PL] =action[13][MI] =action[13][MU] =action[13][DI] =action[13][NS] =\u0026#34;R4\u0026#34;; action[14][RB] =action[14][PL] =action[14][MI] =action[14][MU] =action[14][DI] =action[14][NS] =\u0026#34;R5\u0026#34;; action[15][RB] =action[15][PL] =action[15][MI] =action[15][MU] =action[15][DI] =action[15][NS] =\u0026#34;R7\u0026#34;; //é”™è¯¯åˆ†æç±»å‹ action[1][LB]=action[2][LB]=action[3][LB]=action[5][LB]=action[10][LB]=action[11][LB]=action[12][LB]=action[13][LB]=action[14][LB]=action[15][LB]=\u0026#34;e3\u0026#34;; action[0][RB]=action[1][RB]=action[4][RB]=action[6][RB]=action[7][RB]=action[8][RB]=action[9][RB]=\u0026#34;e2\u0026#34;; action[0][PL]=action[4][PL]=action[6][PL]=action[7][PL]=action[8][PL]=action[9][PL]=\u0026#34;e1\u0026#34;; action[0][MI]=action[4][MI]=action[6][MI]=action[7][MI]=action[8][MI]=action[9][MI]=\u0026#34;e1\u0026#34;; action[0][MU]=action[4][MU]=action[6][MU]=action[7][MU]=action[8][MU]=action[9][MU]=action[1][MU]=action[10][MU]=\u0026#34;e1\u0026#34;; action[0][DI]=action[4][DI]=action[6][DI]=action[7][DI]=action[8][DI]=action[9][DI]=action[1][DI]=action[10][DI]=\u0026#34;e1\u0026#34;; action[1][\u0026#39;i\u0026#39;]=action[2][\u0026#39;i\u0026#39;]=action[3][\u0026#39;i\u0026#39;]=action[5][\u0026#39;i\u0026#39;]=action[10][\u0026#39;i\u0026#39;]=action[11][\u0026#39;i\u0026#39;]=action[12][\u0026#39;i\u0026#39;]=action[13][\u0026#39;i\u0026#39;]=action[14][\u0026#39;i\u0026#39;]=action[15][\u0026#39;i\u0026#39;]=\u0026#34;e3\u0026#34;; action[0][NS]=action[4][NS]=action[6][NS]=action[7][NS]=action[8][NS]=action[9][NS]=\u0026#34;e1\u0026#34;; action[10][NS]=\u0026#34;e4\u0026#34;; Goto[0][\u0026#39;E\u0026#39;] = 1; Goto[0][\u0026#39;T\u0026#39;] = 2; Goto[0][\u0026#39;F\u0026#39;] = 3; Goto[4][\u0026#39;E\u0026#39;] = 10; Goto[4][\u0026#39;T\u0026#39;] = 2; Goto[4][\u0026#39;F\u0026#39;] = 3; Goto[6][\u0026#39;T\u0026#39;] = 11; Goto[6][\u0026#39;F\u0026#39;] = 3; Goto[7][\u0026#39;T\u0026#39;] = 12; Goto[7][\u0026#39;F\u0026#39;] = 3; Goto[8][\u0026#39;F\u0026#39;] = 13; Goto[9][\u0026#39;F\u0026#39;]= 14; strcpy(follow[\u0026#39;E\u0026#39;],\u0026#34;#)+-\u0026#34;); strcpy(follow[\u0026#39;T\u0026#39;],\u0026#34;#)+_*/\u0026#34;); strcpy(follow[\u0026#39;F\u0026#39;],\u0026#34;#)+_*/\u0026#34;); sta[++stat]=0; syb[++sybt]=NS; } void superSLR1(FILE *fp){ printf(\u0026#34;å¼€å§‹slråˆ†æï¼š\\n\u0026#34;); slr_init(); string str;//å­˜å‚¨æ¯ä¸€æ­¥çš„è¡¨è¾¾å¼ bool x=true;//åˆæ³•ä½ int index;//ç™»è®°ä½ index = scan(fp); topsta = sta[stat];//çŠ¶æ€æ ˆ inpsym = chra[index];//ç¬¦å·æ ˆ str=action[topsta][inpsym];//å¯¹åº”å…¬å¼ FILE * result = fopen(\u0026#34;/home/zql/CLionProjects/cpex/result.txt\u0026#34;,\u0026#34;w\u0026#34;); fputs(\u0026#34;å®éªŒä¸‰ä¸­é—´ä»£ç ç”Ÿæˆå¦‚ä¸‹ï¼š\\n\u0026#34;,result); while(str!=\u0026#34;Acc\u0026#34;){ if(str[0]==\u0026#39;S\u0026#39;){ int num; if(str.length()==2) num = str[1]-\u0026#39;0\u0026#39;; else if(str.length()==3)num=(str[1]-\u0026#39;0\u0026#39;)*10+str[2]-\u0026#39;0\u0026#39;; mea[++meat] = index;//å½“å‰ç¬¦å·å…¥è¯­ä¹‰æ ˆ if(chra[index]==\u0026#39;i\u0026#39;)T[index]=-1;//å¦‚æœæ˜¯æ•°å€¼ï¼Œä¿ç•™å­˜å‚¨ä½ç½® //ä¸‹ä¸€ä¸ªçŠ¶æ€å…¥çŠ¶æ€æ ˆï¼Œä¸ä¼šå‡ºé”™ sta[++stat] = num; //è¯»å…¥ä¸‹ä¸€ä¸ªç¬¦å·ï¼Œå¯èƒ½ä¼šè¯»åˆ°é”™è¯¯çš„éç»ˆç»“ç¬¦å· index = scan(fp); //å…¥ç¬¦å·æ ˆ syb[++sybt] = chra[index]; if(mode==2){ printf(\u0026#34;ç§»è¿›æ“ä½œ, %då…¥çŠ¶æ€æ ˆ, %då…¥ç¬¦å·æ ˆ, è¾“å…¥ä¸²é¦–ä¸º%d\\n\u0026#34;,num,syb[sybt],chra[index]); } } else if(str[0]==\u0026#39;R\u0026#39;){ int num = str[1]-\u0026#39;0\u0026#39;;//è¡¨è¾¾å¼ç¼–å· string r = R1[num][1]; if(mode==2){ cout\u0026lt;\u0026lt;\u0026#34;å½’çº¦æ“ä½œ, æ ¹æ®R\u0026#34;\u0026lt;\u0026lt;num\u0026lt;\u0026lt;\u0026#34;, è¡¨è¾¾å¼ä¸º\u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34;,\u0026#34;; } int len = r.length(); stat-=len; sybt-=len; gen(num,result);//è®¡ç®—å¹¶ä¸”ç”Ÿæˆå››å…ƒå¼ meat-=len; topsta = sta[stat]; syb[++sybt]=R1[num][0][0];//è§„çº¦ if(mode==2){ printf(\u0026#34; è§„çº¦ä¸ºçš„éç»ˆç»“ç¬¦å·%cï¼Œå…¥ç¬¦å·æ ˆ,\u0026#34;,syb[sybt]); } sta[++stat]=Goto[topsta][syb[sybt]]; mea[++meat] = idx; if(mode==2){ printf(\u0026#34; è§„çº¦å%då…¥çŠ¶æ€æ ˆ\\n\u0026#34;,sta[stat] ); } idx++; } else if (str[0]==\u0026#39;e\u0026#39;){ //è¯´æ˜æŒ‰ç…§strä¸­çš„ä½ç½®æ‰¾åˆ°çš„é”™è¯¯ï¼Œåˆ™å½“å‰ç¬¦å·æ ˆé¡¶çš„ç¬¦å·æ˜¯é”™è¯¯çš„ int num= str[1]-\u0026#39;0\u0026#39;; report_error(num+10); if(num==4)break; x=false; // è·³è¿‡å½“å‰çš„ç»ˆç»“ç¬¦å·ï¼Œå°†å½“å‰çŠ¶æ€å’Œä¸‹ä¸€ä¸ªç»ˆç»“ç¬¦å·ç»„åˆï¼Œå¯»æ‰¾ä¸‹ä¸€ä¸ªè¡¨è¾¾å¼ index=scan(fp); syb[sybt] = chra[index]; } //æŸ¥è¡¨ topsta = sta[stat]; inpsym = chra[index]; str=action[topsta][inpsym]; } if(x)printf(\u0026#34;åˆæ³•!\\n\u0026#34;); return ; } //ä¸»å‡½æ•° int main() { printf(\u0026#34;è¯·é€‰æ‹©è¾“å‡ºç»“æœç±»å‹(æŸ¥çœ‹å®éªŒä¸€ç»“æœè¯·è¾“å…¥1ï¼Œç±»æ¨):\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;mode); FILE* test = fopen(\u0026#34;/home/zql/CLionProjects/cpex/text\u0026#34;,\u0026#34;r\u0026#34;); superSLR1(test); fclose(test); return 0; } \\ ","permalink":"https://zqlqy.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/","summary":"#include \u0026lt;cstring\u0026gt; #include \u0026lt;valarray\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; //å®å®šä¹‰å£°æ˜ //å®ç°è¯æ³•åˆ†ææ‰€éœ€ //å®å®šä¹‰å„ç§ç¬¦å·ç±»å‹ #define DIGIT 1 #define POINT 2 #define OTHER 3 #define POWER 4 #define PLUS 5 #define MINUS 6 # define ID 7 # define INT 8 # define REAL 9 # define LT 10 # define LE 11 # define EQ 12 # define NE 13 # define GT 14 # define GE 15 # define IS 16 # define PL 17 # define MI 18 # define MU 19 # define DI 20 # define AND 21 # define OR 22 # define NOT 23 # define STR 24 # define CHAR 25 # define OCT 26 # define HEX 27 # define LB 28 # define RB 29 # define NS 30 # define UCON 97 # define ClassOther 200 # define EndState -1 #define MAX_KEY_NUMBER 20 /*å…³é”®å­—çš„æ•°é‡*/ #define KEY_WORD_END \u0026#34;#\u0026#34; /*å…³é”®å­—ç»“æŸæ ‡è®°*/ //è¾“å‡ºè®¾ç½®ï¼ˆä¸ºåŒºåˆ†å®éªŒç»“æœï¼‰ int mode = 0; // å˜é‡å®šä¹‰ // å®ç°è¯æ³•åˆ†ææ‰€éœ€ const int N=10000;// å¤Ÿç”¨ char *KeyWordTable[MAX_KEY_NUMBER]={\u0026#34;begin\u0026#34;,\u0026#34;end\u0026#34;, \u0026#34;const\u0026#34;,\u0026#34;var\u0026#34;,\u0026#34;if\u0026#34;, \u0026#34;else\u0026#34;,KEY_WORD_END};//å…³é”®è¯è¡¨ //å®æ•°åˆ†æ int w,n,p,e,d;//å®æ•°åˆ†ææ‰€éœ€ int Class;//å®æ•°åˆ†æç±»åˆ« int ICON;//å®æ•°åˆ†æ float FCON;//å®æ•°åˆ†æçš„å€¼ static int CurrentState;//å®æ•°åˆ†æå½“å‰çŠ¶æ€ //æ‰«æç”¨ int adx=1,ady=1;//å½“å‰è¯»å…¥çš„ä½ç½® char ch; //å½“å‰è¯»å…¥çš„å­—ç¬¦ï¼Œå¿…é¡»è¦è®¾å®šè¿™ä¸ªå…¨å±€å˜é‡ï¼Œåœ¨å›é€€ä¹‹å‰æ£€æŸ¥ä¸€ä¸‹æ˜¯å¦ä¸ºEOF,åœ¨scannerä¸­ä¸ºEOFä¸å›é€€ char TOKEN[20];//æ¯ä¸ªè¯»å…¥å•è¯ //å®ç°è¯­æ³•åˆ†ææ‰€éœ€ int sta[10010];//çŠ¶æ€æ ˆ int syb[10010];//ç¬¦å·æ ˆ int mea[1010];//è¯­ä¹‰æ ˆ int stat=0,sybt=0; int meat=0;//ä»¥ä¸Šä¸‰æ ˆçš„æ ˆé¡¶ int topsta;//çŠ¶æ€æ ˆé¡¶,åœ¨actionè¡¨ä¸­ç”¨ int inpsym;//è¾“å…¥ç¬¦å·ä¸²é¡¶ï¼Œåœ¨actionè¡¨ä¸­ç”¨ //è¯­æ³•æœ¬èº« char* action[200][200];//actionè¡¨ int Goto[200][200];//gotoè¡¨ string R1[100][2]= {{\u0026#34;S\u0026#34;,\u0026#34;E\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E+T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;E-T\u0026#34;},{\u0026#34;E\u0026#34;,\u0026#34;T\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;}, {\u0026#34;T\u0026#34;,\u0026#34;T*F\u0026#34;},{\u0026#34;T\u0026#34;,\u0026#34;F\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;(E)\u0026#34;},{\u0026#34;F\u0026#34;,\u0026#34;i\u0026#34;}};//è¯­æ³• char follow[300][50]; //å®ç°è¯­ä¹‰åˆ†ææ‰€éœ€ int idx=0;//æ¯ä¸ªé”®å€¼å¯¹çš„ç´¢å¼•ï¼ˆkey,valueï¼‰ string valu[N];//æ¯ä¸ªå•è¯çš„å€¼ int cla[N];//æ¯ä¸ªå•è¯çš„ç±»å‹ int chra[N];//æ¯ä¸ªå•è¯åœ¨è¯­æ³•ä¸­æ‰®æ¼”çš„è§’è‰² int T[N]={}; int tt=1;//ä¸´æ—¶å˜é‡ç¼–å· //å‡½æ•°å®šä¹‰ //æŠ¥é”™å‡½æ•° void report_error(int errcla){ int k=0; char* str; switch (errcla){ case 1: str = \u0026#34;åå…­è¿›åˆ¶æ•°è¡¨ç¤ºé”™è¯¯\u0026#34;; break; case 2: str = \u0026#34;å…«è¿›åˆ¶æ•°è¡¨ç¤ºé”™è¯¯\u0026#34;; break; case 3: str = \u0026#34;å­—ç¬¦å‹å¸¸é‡å®šä¹‰é”™è¯¯\u0026#34;; break; case 4: str = \u0026#34;éæ³•è¿ç®—ç¬¦\u0026#34;; break; case 5: str = \u0026#34;æœªå®šä¹‰ç¬¦å·\u0026#34;; break; case 6: str=\u0026#34;è¯­æ³•é”™è¯¯\u0026#34;; k=1; break; case 7: str = \u0026#34;æœªæ‰¾åˆ°è¡¨è¾¾å¼\u0026#34;; k=2; break; case 8: str = \u0026#34;ä¸æ˜¯ç®—ç¬¦ä¼˜å…ˆæ–‡æ³•\u0026#34;; k=2; break; case 11: str=\u0026#34;ç¼ºå°‘è¿ç®—åˆ†é‡\u0026#34;; k=2; break; case 12: str=\u0026#34;ä¸åŒ¹é…çš„å³æ‹¬å·\u0026#34;; k=2; break; case 13: str=\u0026#34;ç¼ºå°‘è¿ç®—ç¬¦\u0026#34;; k=2; break; case 14: str=\u0026#34;ç¼ºå°‘å³æ‹¬å·\u0026#34;; k=2; break; } if(!","title":"ç¼–è¯‘åŸç†å®éªŒ"}]